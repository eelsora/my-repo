# 8. 통합점: 게이트웨이, 터널, 릴레이

HTTP 위에 다른 프로토콜을 얹으려고 하는 개발자들에게는 HTTP가 기본 구성 요소이다. (예를들어 HTTP만 허용하는 방화벽이 있는 회사에서 다른 프로토콜로 통신하는 트래픽을 HTTP로 감싸서 터널링 하거나 릴레이 하는 것) HTTP는 웹에 있는 모든 리소스에 대한 프로토콜로 사용되었으며, 애플리케이션 간에 상호 다른 프토코롤을 상호 운용하는 용도로 사용하기도한다.

이 장에선 여러종류의 리소스에 접근하는데 HTTP가 어떻게 쓰이는지, 다른 프로토콜이나 애플리케이션 통신에 HTTP를 어떻게 사용하는지 알아본다.

- 게이트웨이: 서로 다른 프로토콜과 애플리케이션 간의 HTTP 인터페이스이다.
- 애플리케이션 인터페이스: 서로 다른 형식의 웹 애플리케이션이 통신하는데 사용한다.
- 터널: HTTP 커넥션을 통해서 HTTP가 아닌 트래픽을 전송하는데 사용한다.
- 릴레이: 일종의 단순한 HTTP 프락시로, 한번에 한 개의 홉에 데이터를 전달하는데 사용한다.

## 8.1 게이트웨이

게이트웨이는 리소스와 애플리케이션을 연결하는 역할을 한다. 애플리케이션은 게이트웨이에게 요청을 처리해달라고 할 수 있고(HTTP 혹은 그 밖의 정의해 둔 인터페이스를 통해), 게이트웨이는 그에 응답할 수 있다.
게이트웨이는 요청을 받고 응답을 보내는 포털 같이 동작하는데, 동적인 콘텐츠를 생성하거나 데이터베이스에 질의를 보낼 수 있다.

게이트웨이는 HTTP트래픽을 다른 프로토콜로 자동 변환하여, HTTP 클라이언트가 다른 프로토콜을 알 필요 없이 서버에 접속할 수 있게 하기도 한다.

```markdown
## (a) HTTP/FTP 서버 측 FTP 게이트웨이

[HTTP 클라이언트] <-> [게이트웨이] <-> [FTP 서버]

1.  게이트 웨이는 FTP URL을 가리키는 HTTP 요청을 받는다.
2.  게이트웨이는 FTP 커넥션을 맺고 FTP서버에 적절한 명령을 전송한다.
3.  클라이언트는 적절한 HTTP헤더와 함께 HTTP를 통해 문서를 받는다.

## (b) HTTPS/HTTP 클라이언트 측 보안 게이트웨이

[HTTPS 클라이언트] <-> [게이트웨이] <-> [웹 서버]

1.  게이트웨이는 암호화된 웹 요청을 SSL을 통해 받고,
    요청을 해독해서 생성한 일반 HTTP요청을 목적지 서버로 전달한다.
2.  이런 보안 가속기는 원 서버에 고성능 암호화 기능을 제공할 목적으로,
    웹 서버의 바로 앞단(보통 같은 구역 내에)에 위치할 수 있다.

## (c) HTTP/CGI 서버 측 애플리케이션 게이트웨이

[HTTP 클라이언트] <-> [ [앱서버] <- CGI(혹은 다른 API) -> [프로그램] ]

1. 게이트웨이는 애플리케이션 서버 게이트웨이 API를 통해서 HTTP클라이언트를 서버측 애플리케이션 프로그램에 연결한다.
2. 웹에서 물건을 사거나 일기예보를 보거나 주식 시게를 볼 때, 사실은 애플리케이션 서버 게이트웨이를 방문하는 것이다.
```

### 8.1.1 클라이언트 측 게이트웨이와 서버 측 게이트웨이

웹 게이트웨이는 한 쪽에서는 HTTPS로 통신하고 다른 한쪽에서는 HTTP가 아닌 다른 프로토콜로 통신한다.

게이트웨이는 클라이언트 측 프로토콜과 서버 측 프로토콜을 빗금(/)으로 구분해 기술한다.

`<클라이언트 프로토콜>/<서버프로토콜>`

게이트웨이가 HTTP클라이언트와 NNTP 뉴스 서버 사이에 있으면 `HTTP/NNTP` 게이트웨이가 된다.

- 서버 측 게이트웨이는 클라이언트와 HTTP로 통신하고, 서버와는 외래 프로토콜로 통신한다.
- 클라이언트 측 게이트웨이는 클라이언트와 외래 프로토콜로 통신하고, 서버와는 HTTP로 통신한다.

## 8.2 프로토콜 게이트웨이

프락시에 트래픽을 바로 보내는 것과 같이 게이트웨이에도 HTTP트래픽을 바로 보낼 수 있다. 보통 브라우저에 명시적으로 게이트웨이를 설정하여 자연스럽게 트래픽이 게이트웨이를 거쳐가게 하거나, 게이트웨이를 대리서버(리버스 프락시)로 설정할 수 있다.

### 8.2.1 HTTP/\* : 서버 측 웹 게이트웨이

서버 측 웹 게이트웨이는 클라이언트로부터 HTTP요청이 원 서버 영역으로 들어오는 시점에 클라이언트 측의 HTTP 요청을 외래 프로토콜로 전환한다. 게이트웨이는 원 서버의 FTP포트(21포트)로 FTP 커넥션을 연결하고 FTP 프로토콜을 통해서 객체를 가져온다.

- 게이트웨이가 하는일
  1. USER와 PASS 명령을 보내서 서버에 로그인한다.
  2. 서버에서 적절한 디렉터리로 변경하기 위해 CWD 명령을 내린다.
  3. 다운로드 형식을 ASCII로 설정한다.
  4. MDTM으로 문서의 최근 수정 시간을 가져온다.
  5. PASV로 서버에게 수동형 데이터 검색을 하겠다고 말한다.
  6. RETR로 객체를 검사한다.
  7. 제어 채널에서 반환된 포트로 FTP서버에서 데이터 커넥션을 맺는다. 데이터 채널이 열리는대로 객체가 게이트웨이로 전송된다.
  게이트웨이는 객체를 받는대로 HTTP응답에 실어서 클라이언트에 전송할 것이다.

### 8.2.2 HTTP/HTTPS : 서버 측 보안 게이트웨이

```markdown
## 내부 HTTP/HTTPS 보안 게이트웨이

[HTTP 클라이언트]

    ⬇️ (HTTP) GET http://www.cnn.com/~~~

[HTTP/HTTPS 인바운드 보안 게이트웨이]

    ⬇️ (SSL(HTTPS)을 통한 HTTP) mdsnrt732~~~

(443포트)[보안 웹서버]
```

기업 내부의 모든 웹 요청을 암호화 함으로써 개인 정보 보호와 보안을 제공하는데 게이트웨이를 사용할 수 있다.

클라이언트는 일반 HTTP를 사용하여 웹을 탐색할 수 있지만, 게이트웨이는 자동으로 사용자의 모든 세션을 암호화한다.

### 8.2.3 HTTS/HTTP: 클라이언트 측 보안 가속 게이트웨이

HTTPS/HTTP 게이트웨이는 보안 가속기로 유명하다. 이 HTTPS/HTTP게이트웨이는 웹 서버 앞단에 위치하고, 보이지 않는 인터셉트 게이트웨이나 리버스 프락시 역할을한다. 이 게이트웨이는 보안 HTTPS 트래픽을 받아서 복호화 하고, 웹 서비스로 보낼 일반 HTTP요청을 만든다.

```markdown
## HTTPS/HTTP 보안 가속 게이트웨이

[브라우저]

    ⬇️ (SSL(HTTPS)를 통한 HTTP) mdsnrt732~~~

[HTTPS/HTTP 보안 가속 게이트웨이]

    ⬇️ (HTTP) GET http://www.cnn.com/~~~

[www.cnn.com]
```

이런 게이트웨이는 보안 트래픽을 복호화 하는 암호화 하드웨어를 내장해서 원 서버 부하를 줄여주기도 하지만 원 서버간의 암호화 하지 않은 트래픽을 전송하기 때문에, 게이트웨이와 원 서버간에 있는 네트워크가 안전한지 확인을 확실히 하고 사용해야한다.

## 8.3 리소스 게이트웨이

게이트웨이의 가장 일반적인 형태인 애플리케이션 서버는 목적지 서버와 게이트웨이 서버를 한개의 서버로 결합한다. 애플리케이션 서버는 HTTP를 통해서 클라이언트와 통신하고 서버 측에 있는 애플리케이션 프로그램에 연결하는 서버측 게이트웨이이다.

애플리케이션 게이트웨이에서 유명했던 최초의 API는 공용 게이트웨이 인터페이스 (Common Gateway Interface, CGI)이다. CGI는 특정 URL에 대한 HTTP요청에 따라 프로그램을 실행하고, 프로그램의 출력을 수집하고, HTTP응답으로 회신하는데 웹서버가 사용하는 표준화된 인터페이스 집합이다.

- 서버 게이트웨이 애플리케이션의 동작
  1. 게이트웨이를 통해야 받을수 있는 리소스 요청이 들어옴
  2. 서버는 헬퍼 애플리케이션을 생성하여 요청을 처리함
  3. 헬퍼 애플리케이션은 필요한 데이터를 전달받음
  4. 클라이언트로 전달할 응답이나 응답할 데이터를 서버에 반환함

### 8.3.1 공용 게이트웨이 인터페이스

CGI(Common Gateway Interface)는 최초의 서버 확장이자 지금까지도 가장 널리 쓰이는 서버 확장이다.

이는 웹에서 동적인 HTML, 신용카드 처리, 데이터베이스 질의 등을 제공하는데 사용한다.

CGI 애플리케이션이 서버와 분리되면서 펄(Perl), Tcl, C, 다양한 셸 언어를 포함하여 수많은 언어로 구현할 수있게 되었다.

CGI가 내부에서 어떤 처리를 하는지 사용자에게 보여지진 않고, 클라이언트가 CGI 애플리케이션이 무언가 하고있다는 것을 알 수 있는 유일한 단서는 URL에 있는 ‘cgi’ 혹은 ‘?’ 같은 것 들 뿐이다.

CGI는 거의 모든 리소스 형식과 서버의 접점에 있으면서 필요에 따라 어떤 형이든 처리해내는 단순한 기능을 제공한다.

Fast CGI는 CGI와 유사하지만, 데몬으로 동작함으로써 요청마다 새로운 프로세스를 만들고 제거하면서 생기는 성능 저하 문제를 해결하였다.

### 8.3.2 서버 확장 API

확장 API는 프로그래머가 자신의 코드를 서버에 연결하거나 서버의 컴포넌트를 자신이 만든 것으로 교채해버릴 수 있게하였다.

유명한 서버 대부분은 개발자에게 확장 API를 한 개 이상 제공한다. 이러한 확장은 서버 자체의 아키텍처에 의존하기 때문에, 대부분 한가지 서버 형식으로 특화되었다.

FPSE(FrontPage Server Extension)는 프론트 페이지 클라이언트로부터 전송되는 원격 프로시져 호출(remote procedure call, RPC) 명령을 인식할 수 있다. 이 명령은 HTTP에 편승하여 온다.(특히 HTTP POST 메서드상에 붙어서 온다)

## 8.4 애플리케이션 인터페이스와 웹 서비스

애플리케이션이 상호 운용을 하다보면 HTTP 헤더로는 표현하기 힘든 복잡한 정보를 교환해야 할 수도 있다.

인터넷 커뮤니티는 각 웹 애플리케이션이 서로 통신하는데 사용할 표준과 프로토콜 집합을 개발하였다. 이런 표준은 원래 웹 서비스가 독립형 웹 어플리케이션 그 자체를 의미함에도 불구하고, 그냥 그대로 웹 서비스로 불리게 되었다.

웹 서비스는 SOAP를 통해 XML을 사용하여 정보를 교환한다. XML(eXtemsible Marup Language)은 데이터 객체를 담는 데이터를 생성하고 해석하는 방식을 제공한다. SOAP(Simple Object Access Protocol)은 HTTP 메세지에 XML 데이터를 담는 방식에 관한 표준이다.

## 8.5 터널

웹터널은 HTTP프로토콜을 지원하지 않는 애플리케이션에 HTTP 어플리케이션을 사용해 접근하는 방법을 제공한다.

웹 터널을 사용하면 HTTP 커넥션을 통해서 HTTP가 아닌 트래픽을 전송할 수 있고, 다른 프로토콜을 HTTP위에 올릴 수 있다. 웹 터널을 사용하는 가장 일반적인 이유는 HTTP 커넥션 안에 HTTP가 아닌 트래픽을 얹기 위해서이다. 따라서 웹 터널을 사용하면 웹 트래픽만을 허락하는 방화벽이 있더라도 HTTP가 아닌 트래픽을 전송할 수 있다.

### 8.5.1 CONNECT로 HTTP 터널 커넥션 맺기

웹 터널은 HTTP의 CONNECT로 메서드를 사용하여 커넥션을 맺는다.

CONNECT 메서드는 터널 게이트웨이가 임의의 목적 서버와 포트에 TCP 커넥션을 맺고 클라이언트와 서버 간에 오는 데이터를 무조건 전달하기를 요청한다.

- **CONNECT요청**
  CONNECT 문법은 시작줄을 제외하고 다른 HTTP 메서드와 같다. 요청 URI는 호스트명이 대신하며 콜론에 이어 포트를 기술한다. - `CONNECT home.netscape.com:443 HTTP/1.0
    User-agent: Mozilla/4.0`
      시작줄 다음에는 다른 HTTP 메세지와 같이 추가적인 HTTP 요청 헤더 필드가 있거나 없다.
- **CONNECT 응답**
  클라이언트는 요청을 전송한 다음, 게이트웨이의 응답을 기다린다. 일반 메세지와 같이 200 응답코드는 성공을 뜻한다. 편의상 응답에 있는 사유구절은 ‘Connection Established’로 기술된다 - `HTTP/1.0 200 Connection Established
    Proxy-agent: Netscape-Proxy/1.1`
      일반적인 HTTP응답과 달리 Content-Type 헤더를 포함할 필요는 없다. 커넥션이 메세지를 전달하는 대신 바이트를 그대로 전달하기 때문에 콘텐츠의 형식을 기술하는 Content-Type 헤더를 포함함 필요가 없다.

### 8.5.2 데이터 터널링, 시간, 커넥션 관리

- **게이트웨이**는 터널을 통해 전달되는 데이터를 **볼 수 없으며**, **패킷의 흐름이나 순서를 예측할 수 없다**.
- 클라이언트는 **CONNECT 요청 후 응답을 기다리지 않고 데이터 전송을 시작할 수 있다**.
  → 성능 향상을 위한 방식이지만, 게이트웨이는 이를 처리할 준비가 되어 있어야 함.
- 게이트웨이는 **헤더만 읽을 수 있을 것이라는 가정을 해선 안 되며**, 받은 모든 데이터를 즉시 서버로 전달해야 한다.
- 클라이언트는 **200 응답이나 인증 요구가 오면 데이터 재전송 가능 상태**여야 한다.
- **터널 끝단 중 한쪽 커넥션이 끊기면**, 반대쪽도 프락시가 끊고, **아직 전송되지 않은 데이터는 폐기된다.**

### 8.5.3 SSL 터널링

- **SSL 트래픽을 기존 프락시나 방화벽을 통과시키기 위해**, HTTP에 **터널링 기능이 추가**되었다.
- 터널링은 **암호화된 데이터를 HTTP 메시지 안에 담아**, **HTTP 포트(80)**를 통해 전송한다.
- 방화벽은 이를 일반 HTTP 트래픽처럼 받아들이며, 결과적으로 **SSL 트래픽이 보안 웹 서버로 전달**된다.
- 즉, **HTTP 터널을 통해 SSL 통신이 443 포트가 아닌 80 포트로 우회**되는 셈이다.
- 이 방식은 **보안 연결이 필요한 트래픽을 방화벽이 제한하는 환경에서 유용**하지만, 동시에 **악성 트래픽이 우회 유입되는 보안 취약점**이 될 수도 있다.

### 8.5.4 SSL 터널링 vs HTTP/HTTPS 게이트웨이

- HTTPS는 일반 프로토콜처럼 **게이트웨이를 통해 통신할 수 있지만**, 이때 **프락시가 SSL을 대신 처리**해야 한다.
- 이 방식은 클라이언트와 프락시 사이가 **일반 HTTP(암호화되지 않음)**로 통신하게 되어 **보안상 취약**하다.
- **SSL 클라이언트 인증**(예: X.509 인증서)이 불가능하고,
- **프락시가 SSL 기능을 완전히 구현**해야 한다는 부담이 있다.
- **대안: SSL 터널링 사용**
  - **SSL 터널링을 사용하면**, SSL 세션은 **클라이언트 ↔ 서버 사이에서 직접 맺어짐**.
  - **프락시는 단순히 암호화된 데이터를 전달만** 하므로, **프락시가 SSL을 이해하거나 복호화할 필요가 없다**.
  - 이 방식은 보안을 유지하면서도 프락시를 단순화할 수 있다.

### 8.5.5 터널 인증

HTTP의 다른 기능들은 터널과 함께 적절히 사용할 수 있다. 특히 프락시 인증 기능은, 클라이언트가 터널을 사용할 수 있는 권한을 검사하는 용도로 터널에서 사용할 수있다.

### 8.5.6 터널 보안에 대한 고려사항들

악의적으로 우회하여 터널을 사용하는 경우가 있을 수 있기 때문에 게이트웨이는 HTTPS 전용 포트인 443같이 잘 알려진 특정 포트만 터널링할 수 있게 허용해야한다.

## 8.6 릴레이

HTTP 릴레이는 클라이언트의 HTTP 요청을 중간 서버(릴레이 서버)가 받아 최종 목적지 서버로 전달하고, 응답도 다시 클라이언트에게 중계해주는 방식이다. 이는 보안 분리, 요청 로깅, 트래픽 제어, IP 은닉 등의 목적에 사용되며, 내부망과 외부망 간의 통신을 간접적으로 허용하는 데 유용하다. 프록시나 SSL 터널링과 달리 평문 HTTP 요청을 중계하며, 요청 내용을 열람하거나 조작할 수 있는 구조다.
