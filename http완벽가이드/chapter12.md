# 12. 기본인증

인증은 당신이 누구인지 증명하는 것이다. 보통은 사용자 이름과 비밀번호를 입력하여 인증하며, HTTP는 자체적인 인증 관련 기능을 제공한다.

## 12.1 인증

당신이 누구인지 증명하는 것이며 완벽한 인증이라는 없고, 위조 당할 수 있다. 하지만 여러 데이터는 누구인지 판단하는데 도움이 된다.

### 12.1.1 HTTP의 인증요구/응답 프레임워크

HTTP는 사용자 인증을 하는 데 사용하는 자체 인증요구/응답 프레임워크를 제공한다.

1. `요청`: 클라이언트 → 서버
2. `인증요구`: 클라이언트 ← 서버
3. `인가`(클라이언트에게 비밀번호 물어봄): 클라이언트 → 서버
4. `인증 성공`

### 12.1.2 인증 프로토콜과 헤더

HTTP는 필요에 따라 고쳐 쓸 수 있는 제어 헤더를 통해, 다른 인증 프로토콜에 맞추어 확장할 수 있는 프레임워크를 제공한다.

- 인증 요구 : `WWW-Authenticate`
  - 401 Unauthorized
- 인증: `Authorization`
- 성공: `Authentication-Info`

### 12.1.3 보안 영역

접근 권한이 없는 페이지에 접근 하려 할 경우에 아래와 같은 정보로 확인할 수 있다.

realm 파라미터는 영역 그룹을 나타낸다. 해당 유저는 `Corporate Financials` 그룹에만 접근 가능하다.

`HTTP/1.0 401 Unauthorized
WWW-Authenticate: Basic realm=”Corporate Financials”`

## 12.2 기본인증

### 12.2.1 기본 인증의 예

401 상태 코드와 함께, 클라이언트가 접근하려고 했던 보안 영역을 WWW-Authenticate에 기술해 응답하여 인증 요구를 시작한다. 인증 정보를 포함하여 요청하라는 응답을 받은 브라우저는 사용자에게 계정, 비밀번호 입력 대화상자를 열고 입력을 받은 후 사용자가 해당 영역에 접근 권한이 있는지 검사한다.

브라우저는 사용자가 입력한 이름, 비밀번호를 Authorization 요청 헤더안에 암호화 해서 서버로 다시 보낸다.

### 12.2.2 Base-64 사용자 이름/비밀번호 인코딩

base-64 인코딩은 8비트 바이트로 이루어져있는 시퀀스를 6비트 덩어리의 시퀀스로 반환한다.

Base-64 인코딩은 바이너리, 텍스트, 국제 문자 데이터 문자열을 받아서 전송할 수 있게, 그 문자열을 전송 가능한 문자인 알파벳으로 변환하기 위해 발명되었다. 전송 중에 원본 문자열이 변질될 걱정 없이 원격에서 디코딩 할 수 있다.

이를 통해 HTTP 헤더에서 사용자 정보를 노출되지 않도록 문제를 예방할 수 있따.

### 12.2.3 프락시 인증

중개 프락시 서버를 통해 인증할 수 있다. 어떤 회사는 사용자들이 회사 서버나 LAN이나 무선 네트워크에 접근 전에 프락시 서버를 거치게 하여 사용자를 인증한다. 프라깃 서버에서는 접근 정책을 중앙 관리 할 수 있기 때문에 회사 리소스 전체에 대해 통합적인 접근제어를 하기 위해 프락시 서버를 사용하면 좋다.

## 12.3 기본 인증의 보안 결함

1. 기본인증(사용자 이름, 비밀번호) 디코딩 할 수 있는 형식으로 네트워크에 전송하게 되면 좋지 않은 의도를 가진 외부업자가 손쉽게 디코딩하여 개인정보를 가로챌 수 있다. 모든 HTTP 트랜잭션을 SSL 암호화 채널로 보내거나, 보안이 더 강화된 다이제스트 인증 같은 프로토콜을 사용하는것이 좋다.
2. 디코딩 하기 더 복잡하게 한다고 해도 제삼자는 그를 캡쳐하여 그대로 원서버에 보내 인증을 성공시킬 수 있다.
3. 기본인증이 사용되는 동일한 사용자 이름, 비밀번호를 사용하는 타 사이트에서도 그대로 사용할 경우 이는 중요한 은행 사이트 등과같은 곳에서도 쓰일 수 있다.
4. 메세지의 인증 헤더를 건드리진 않지만 그 외 다른 부분을 수정해서 트랜잭션의 본래 의도를 바꿔버리는 프락시나 중개자가 중간에 개입하는 경우, 기본인증의 정상 동작을 보장하지 않는다.
5. 가짜 서버의 위장에 취약하다.
