# 14. 보안 HTTP

적대 행위가 일어날 가능성이 있는 커뮤니티에서 중요한 HTTP 트랜잭션을 보호하기 위해선 더 복잡하고 적극적인 기술이 있다.

## 14.1 HTTP를 안전하게 만들기

은행 업무, 보안자료 업로드 등의 중요한 일을 할 경우엔 안전한 HTTP 트랜잭션이 보장되어야한다.

- 서버인증: 클라이언트는 자신이 위조된 서버가 아닌 진짜와 이야고 있음을 알 수 있어야한다.
- 클라이언트 인증: 서버는 자신이 가짜가 아닌 진짜 사용자와 이야기하고 있음을 알 수 있어야한다.
- 무결성: 클라이언트와 서버는 그들의 데이터가 위조되는 것으로부터 안전해야한다.
- 암호화: 클라이언트와 서버는 도청에 대한 거정 없이 서로 대화할 수 있어야 한다.
- 효율: 저렴한 클라이언트나 서버도 이용할 수 있도록 알고리즘은 충분히 빨라야한다.
- 편재성(Ubiquity): 프로토콜은 거의 모든 클라이언트와 서버에서 지원되어야 한다.
- 관리상 확장성: 누구든 어디서든 즉각적인 보안 통신을 할 수 있어야한다.
- 적응성: 현재 알려진 최선의 보안 방법을 지원해야한다.
- 사회적 생존성: 사회의 문화적, 정치적 요구를 만족시켜야한다.

### 14.1.1 HTTPS

HTTPS는 HTTP를 안전하게 만드는 방식 중 가장 인기있는 방식이다.

HTTPS를 사용할 때, 모든 HTTP 요청과 응답 데이터는 네트워크로 보내지기 전에 암호화된다. HTTPS는 HTTP의 하부에 전송 레벨 암호 보안 계층을 제공함으로써 동작하는데, 이 보안계층은 **안전한 소켓 계층(Secure Sockets Layer, SSL)** 혹은 그를 계승한 **전송 계층 보안 (Transport Layer Security, TLS)**을 이용하여 구현된다.

어려운 인코딩, 디코딩 작업은 대부분 SSL 라이브러리 안에서 일어나기 때문에, 보안 HTTP를 사용하기 위해 웹 클라이언트와 서버가 프로토콜을 처리하는 로직을 크게 변경할 필요는 없다. 대부분의 경우 TCP 입력/출력 호출을 SSL 호출로 대체하고, 보안 정보를 설정하고 관리하기 위한 몇가지 호출을 추가하기만 하면 된다.

## 14.2 디지털 암호학

- 암호: 텍스트를 아무나 읽지 못하도록 인코딩하는 알고리즘
- 키: 암호의 동작을 변경하는 숫자로 된 매개변수
- 대칭키 암호 체계: 인코딩과 디코딩에 같은 키를 사용하는 알고리즘
- 비대칭키 암호 체계: 인코딩과 디코딩에 다른 키를 사용하는 알고리즘
- 공개키 암호법: 비밀 메시지를 전달하는 수백만대의 컴퓨터를 쉽게 만들 수 있는 시스템
- 디지털 서명: 메시지가 위조 혹은 변조되지 않았음을 증명하는 체크섬
- 디지털 인증서: 신뢰할만한 조직에 의해 서명되고 검증된 신원확인정보

### 14.2.1 비밀 코드의 기술과 과학

암호법(cyptography)은 메세지 인코딩과 디코딩에 대한 과학이자 기술이다.

암호법은 메세지를 암호화 하는것 뿐 아니라 메세지의 변조를 방지하기 위해 사용할 수도있다.

### 14.2.2 암호(cipher)

암호법은 암호라 불리는 비밀코드에 기반한다. 암호란 메세지를 인코딩하는 어떤 특정한 방법과 나중에 그 비밀메세지를 디코딩하는 방법이다. 인코딩되기 전의 원본 메세지는 흔히 텍스트 혹은 평문 이라고 불린다. 암호가 적용되어 코딩된 메세지는 보통 암호문이라고 불린다.

### 14.2.3 암호 기계

기술이 진보하면서 사람들은 보다 복잡한 암호로 메세지를 빠르고 정확하게 인코딩, 디코딩하는 기계를 만들어냈다.

### 14.2.4 키가 있는 암호

오늘날 거의 대부분의 암호알고리즘은 키를 사용한다. 암호키는 하나의 암호기계를 여러 가상 암호기계의 집합처럼 만들어준다. 하나의 인코더로 다른 키를 입력하면 각각 다른 암호문을 만들어 준다.

### 14.2.5 디지털 암호

디지털 계산의 도래로 발전된 두가지.

1. 속도 및 기능 제한에서 벗어나 복잡한 인코딩과 디코딩 알고리즘이 가능해짐
2. 매우 큰 키를 지원하는 것이 가능해져서, 단일 암호 알고리즘으로 키의 값마다 다른 수조개의 가상 알고리즘을 만들어낼 수 있게됨.

코딩 알고리즘은 데이터 덩어리를 받아서 알고리즘과 키의 값에 근거하여 인코딩 하거나 디코딩하는 함수이다.

## 14.3 대칭키 암호법

인코딩할 때 사용하는키가 디코딩할 때 사용하는 키와 같은것을 대칭키 암호라고 부른다.

잘 알려진 대칭키 암호 알고리즘으로는 DES, Triple-DES, RC2, RC4 등이 있다.

### 14.3.1 키 길이와 열거 동작(Enumeration Attack)

무차별적으로 모든 키 값을 대입해 보는 공격을 열거 공격이라고 한다.

키값의 크기가 클 수록 무차별 대입으로 암호를 실질적으로 깨트리기가 힘들다.

### 14.3.2 공유키 발급하기

대칭키 암호의 단점 중 하나는 발송자와 수신자가 서로 대화하려면 둘 다 공유키를 가져야한다는 것이다.

만약 N개의 노드가 있고 각 노드가 상대 N-1과 은밀하게 대화를 나눠야한다면 N의 2제곱 개의 비밀키가 필요하며, 이는 키를 관리하는 사람 입장에서는 지옥이다.

## 14.4 공개키 암호법

한 쌍의 호스트가 하나의 인코딩/디코딩 키를 사용하는 대신, 공개키 암호 방식은 두 개의 비대칭 키를 사용한다.

하나는 호스트 메세지를 인코딩하고, 다른 하나는 그 호스트의 메시지를 디코딩하기 위해 사용된다. 인코딩 키는 모두를 위해 공개 되어있다.(\*그래서 공개키 암호화 방식이라고도 한다). 하지만 호스트만이 개인 디코딩 키를 알고있다.

키의 분리는, 메세지의 인코딩은 누구나 할 수 있도록 해주는 동시에, 메세지를 디코딩하는 능력은 소유자에게만 부여한다. 이는 노드가 서버로 안전하게 메세지를 발송하는것을 더 쉽게 해주는데, 왜냐하면 서버의 공개키만 있으면 되기 때문이다.

- 공개키 암호는 인코딩과 디코딩에 다른 키를 사용하는 비대칭이다.
- 공개키 암호방식은 호스트마다 한 개의 공개키를 할당한다.

### 14.4.1 RSA

공개키 비대칭 암호의 과제는 아래 내용을 악당이 알고있다 해도 비밀인 개인키를 계산할 수 없다고 확신시켜주는것이다.

- 공개키(물론 공개니까 누구나 얻을 수 있음)
- 가로채서 얻은 암호문의 일부(네트워크를 스누핑해서 획득)
- 메세지와 그것을 암호화한 암호문(인코더에 임의의 텍스트를 넣고 실행해서 획든)

이 모든 오구를 만족하는 공개키 암호 체계중 유명한 하나는 RSA 알고리즘이다.

### 14.4.2 혼성 암호 체계와 세션 키

공개키 암호 방식의 알고리즘은 느린편이라 실제로는 혼용해서 쓰는편임

- 공개 키 암호 사용할 경우: 노드들 사이의 안전한 의사소통 채널을 수립할 때
- 대칭키 사용할 경우: 안전한 채널을 통해 무작위 대칭키를 생성하고 교환하여 이후의 나머지 데이터를 암호화 할 경우

## 14.5 디지털 서명

암호 체계는 메세지를 암호화하고 해독하는것 뿐 아니라, 누가 메세지를 썼는지 그리고 그 메세지가 위조되지 않았음을 증명하기 위해 메세지에 서명을 하도록 사용될 수 있다.

### 14.5.1 서명은 암호 체크섬이다

디지털 서명은 메세지에 붙어있는 특별한 암호 체크섬이며 아래 두가지 장점을 가진다

1. 서명은 메세지를 작성한 저자가 누구인지 알려준다. 체크섬은 저자의 개인 ‘서명’처럼 동작한다.
2. 서명은 메세지 위조를 방지한다.체크섬은 저자의 비밀 개인키와 관련되어있기 때문에 침입자는 위조된 메세지에 대한 올바른 체크섬을 날조해낼 수 없다.

## 14.6 디지털 인증서

디지털 인증서(흔히 ‘certs’라고 불림)는 신뢰할 수 있는 기과능로부터 보증 받은 사용자나 회사에 대한 정보를 담고있다.

### 14.6.1 인증서의 내부

인증서 내부에 담고있는 내용

- 대상의 이름(사람, 서버, 조직 등)
- 유효기간
- 인증서 발급자(누가 이 인증서를 보증하는 지)
- 인증서 발급자의 디지털 서명

### 14.6.2 X.509 v3 인증서

디지털 인증서에 대한 전 세계적인 단일 표준은 없으나 다행히 사용되는 대부분의 인증서는 X.509라 불리는 표준화된 서식에 저장하고있다. 다른 종류의 인증서는 다른 필드값을 가지지만 대부분은 x.509 v3 구조를 따른다.

### 14.6.3 서버 인증을 위해 인증서 사용하기

사용자가 HTTPS를 통한 안전한 웹 트렌젝션을 시작하면 브라우저는 자동으로 접속한 서버에서 디지털 인증서를 갖고온다. 서버가 인증서를 갖고있지 않으면 보안 커넥션은 실패한다.

- 서버인증서가 갖고있는 필드들
  - 웹사이트의 이름과 호스트명, 웹사이트의 공개키, 서명 기관의 이름, 서명 기관의 서명

## 14.7 HTTPS의 세부사항

HTTPS는 HTTP프로토콜에 대칭, 비대칭 인증서 기반 암호 기법의 강력한 집합을 결합한 것이다.

### 14.7.1 HTTS 개요

HTTPS는 그냥 보안 전송계층을 통해 전송되는 HTTP이다. HTTPS의 보안계층은 SSL과 그것의 현대적 대체품인 TLS로 구현되어 있다.

### 14.7.2 HTTPS 스킴

클라이언트는 웹 리소스에 대한 트랜젝션을 수행 요청을 받으면 URL의 스킴을 검사한다. 보안이 되는 HTTPS 프로토콜에서의 URL 스킴 접두사는 `https` 이다.

- 평범한 http 스킴이면 서버 80포트로 연결, https 스킴이면 서버 443(기본)로 연결하고 서버와 바이너리 포맷으로 된 몇몇 SSL 보안 매개변수를 교환하며 핸드셰이크.

### 14.7.3 보안 전송 셋업

- 암호화 되지 않은 HTTP 트랜잭션
  1. 클라 → 서버 80포트로 TCP 커넥션 수립
  2. TCP를 통해 보내진 HTTP 요청
  3. 서버→ 클라 TCP를 통해 보내진 HTTP 응답
  4. TCP 커넥션 닫힘
- 암호화된 HTTPS 트랜잭션
  1. 클라 → 서버 443포트로 TCP 커넥션 수립
  2. 클라 ↔ 서버 SSL 보안 매개변수 핸드셰이크
  3. 클라 → 서버 SSL을 통해 보내진 HTTP 요청/TCP를 통해 보내진 암호화된 요청
  4. 서버→ 클라 SSL을 통해 보내진 HTTP 응답/TCP를 통해 보내진 암호화된 응답
  5. 클라↔서버 SSL 닫힘 통지
  6. TCP 커넥션 닫힘

### 14.7.4 SSL 핸드셰이크

SSL 핸드셰이크에서 발생되는 일

1. 클라→서버 암호 후보들을 보내고 서버에 인증서 요구
2. 서버→ 클라 선택된 암호화 인증서를 보냄
3. 클라→ 서버 비밀 정보를 보내고, 클라이언트와 서버는 임시 세션 키를 만듦
4. 클라 ↔ 서버 서로에게 암호화를 시작한다고 말함.

### 14.7.5 서버 인증서

보안 HTTPS 트랜잭션은 항상 서버 인증서를 요구한다. 서버 인증서는 조직의 이름, 주소, 서버 DNS 도메인 이름 등 X.509 v3에서 파생된 인증서이다.

### 14.7.6 사이트 인증서 검사

SSL 자체는 사용자에게 웹 서버 인증서를 검증할 것을 요구하지 않지만, 최신 웹브라우저 대부분은 인증서에 대해 간단한 기본검사를 하고 그 결과를 더 철저한 검사를 할 수 있는 방법과 함께 사용자에게 알려준다.

- 알고리즘의 수행 단계
  - 날짜검사
  - 서명자 신뢰도 검사
  - 서명 검사
  - 사이트 신원 검사

### 14.7.7 가상 호스팅과 인증서

가상 호스트(하나의 서버에 여러 호스트명)로 운영되는 사이트의 보안 트래픽을 다루는 것은 까다로운 경우도 있다.

몇몇 인기있는 웹 서버 프로그램은 오직 하나의 인증서만을 지원한다. 사용자가 인증서의 이름과 정확히 맞지 않는 가상 호스트명에 도착했다면 경고상자가 나타날 것이다.
