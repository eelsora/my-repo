# 10. HTTP/2.0

## 10.1 HTTP/2.0의 등장 배경

HTTP/1.1의 메세지 포맷은 구현의 단순성과 접근성에 주안점을 두고 최적화 되었다.

커넥션 하나를 통해 요청을 하나 보내고, 그에 대한 응답 하나만을 받는 HTTP의 메세지 교환 방식은 단순한 면에선 더할나위 없었지만, 응답을 받아야 그 다음요청을 보낼 수 있었기 때문에 심각한 회피 지연이 있었다.

HTTP/1.1의 성능과 속도 개선을 위해 여러가지 프로토콜 개발이 시작되었고, 구글에서 실험적으로 개발한 SPDY를 통해 성공적인 성공 개선 효과를 보았으며 이를 토대로 HTTP/2.0의 여덟번째 초안까지 생성되었다.

## 10.2 개요

HTTP/2.0은 서버와 클라이언트 사이의 TCP 커넥션 위에서 동작한다. 이 때 TCP 커넥션을 초기화하는것은 클라이언트이다. HTTP/2.0 요청과 응답은 길이가 정의된(최대 16383바이트) 한 개 이상의 프레임에 담긴다. 이 때 HTTP 헤더는 압축되어 담긴다.

프레임들에 담긴 요청과 응답은 스트림을 통해 보내지고, 한 개의 스트림이 한 쌍의 요청과 응답을 처리한다. 하나의 커넥션 위에 여러개의 스트림이 동시에 만들어질 수 있으므로, 여러개의 요청과 응답을 동시에 처리하는 것 역시 가능하다.

HTTP/2.0은 이들ㅇ스트림에 대한 흐름제어와 우선순위 부여 기능도 제공한다.

기존 웹 어플리케이션들과 호환성을 위해 HTTP/2.0은 요청과 응답 메세지의 의미를 HTTP/1.1과 같도록 유지하고 있다.

## 10.3 HTTP/1.1과의 차이점

### 10.3.1 프레임

HTTP/2.0에서 모든 메세지는 프레임에 담겨 전송된다. 모든 프레임은 8바이트의 크기의 헤더로 시작되며, 뒤이어 최대 16383바이트 크기의 페이로드가 온다.

### 10.3.2 스트림과 멀티플렉싱

스트림은 HTTP/2.0 커넥션을 통해 클라이언트와 서버 사이에서 교환되는 프레임들의 독립된 양방향 시퀀스다.

- **요청과 응답은 하나의 스트림을 통해 이루어짐.**
  1. 클라이언트가 새 스트림을 생성하여 요청을 보냄.
  2. 요청을 받은 서버는 그 요청과 같은 스트림으로 응답을 보냄.
  3. 스트림 닫힘.

이런 특징 때문에 수많은 요청이 들어왔을 때 무한히 TCP 커넥션을 만들수 없어 회전지연이 늘어나는 것을 피하긴 어렵다. 파이프라인 커넥션으로 이것을 피할 순 있으나 널리 쓰이진 않는다. (HTTP/1.1을 사용할 경우)

HTTP/2.0에서는 하나의 커넥션에 여러개의 스트림이 동시에 열릴 수 있다! 뿐만 아니라 스트림 우선순위도 가질 수 있다. → 대역폭이 느리면 스트림의 우선순위를 교체함

### 10.3.3 헤더 압축

예전엔 웹 페이지 하나에 요청이 많지 않아 HTTP/1.1 헤더가 아무런 압축 없이 그대로 전송되어도 문제가 발생되지 않았지만 최근엔 웹페이지 하나에 수백개의 요청이 발생될 수도 있기 때문에 회전 지연과 대역폭 양쪽 문제에 실질적인 영향을 끼치게 되었다.

이를 개선하기 위해 HTTP/2.0에서는 HTTP 메세지의 헤더를 압축하여 전송한다.

헤더는 HPACK 명세에 정의된 헤더 압축 방법으로 압축된 뒤 ‘헤더 블록 조각’들로 쪼개져 전송된다. 받는 쪽에서는 이 조각들을 이은 후 압축을 풀어 원래의 헤더 집합으로 복원한다.

(구글 접속해서 통신 프로토콜 보니까 HTTP/3.0 을 쓰고있다.. 이건 클라이언트 요청 IP가 변경되어도 연결이 계속 유지된다고 하는데 우리가 외부에서 wifi 접속이 되어있을때 동영상 스트리밍 시 연결이 끊기면 안되니까 이런 상황일때 굉장히 유용하게 쓰일듯.. 쓰이는 기업들 보니 유투브, 인스타그램 등등있음)

### 10.3.4 서버 푸시

리소스를 푸시하려는 서버는 먼저 클라이언트에게 자원을 푸시할 것임을 PUSH_PROMISE 프레임을 보내어 미리 알려주어야한다. 클라이언트가 PUSH_PROMISE 프레임을 받게되면 해당 프레임의 스트림은 클라이언트 입장에서는 ‘예약됨)상태가 된다. 이 상태에서 클라이언트는 RST_STREAM 프레임을 다시 보내어 푸시를 거절할 수 있다. RST_STREAM을 보내게 되면 그 스트림은 즉각 닫히게 된다. 스트림이 닫히기 전까지 클라이언트는 서버가 푸시하려고 하는 리소스를 요청해서는 안된다.

**서버 푸시를 사용할 때 유의할 점**

- 서버 푸시를 사용하기로 했더라도, 중간의 프락시가 서버로부터 받은 추가 리소스를 클라이언트에게 전달하지 않을 수 있으며, 반대로 아무런 추가 리소스를 서버로부터 받지 않았음에도 클라이언트에게 추가 리소스를 전달할 수 있다.
- 서버는 오직 안전하고, 캐시 가능하고, 본문을 포함하지 않은 요청에 대해서만 푸시할 수 있다.
- 푸시할 리소스는 클라이언트가 명시적으로 보낸 요청과 연관된 것이어야 한다.
  서버가 보내는 PUSH_PROMISE 프레임은 원 요청을 위해 만들어진 스트림을 통해 보내진다.
- 클라이언트는 반드시 서버가 푸시한 리소스를 동일 출처 정책에 따라 검사해야한다.
- 서버 푸시를 끄고싶다면 SETTINS_ENABLE_PUSH를 0으로 설정하면 된다.

## 10.4 알려진 보안 이슈

### 10.4.1 중개자 캡슐화 공격

HTTP/1.1과 달리 HTTP/2.0은 헤더 필드의 이름과 값을 바이너리로 인코딩한다. 이는 HTTP/2.0이 어떤 문자를 써서 헤더필드로 사용해도 허용한다는것을 의미한다.

이는 정상적인 HTTP/2.0 요청이나 응답이, 불법적이나 위조된 HTTP/1.1 메세지로 번역되는 것을 유발할 수 있다.

다행히 HTTP/1.1 → HTTP/2.0 로 번역하는 과정에서는 이런 문제가 발생되지 않는다.

### 10.4.2 긴 커넥션 유지로 인한 개인정보 누출 우려

HTTP/2.0는 사용자가 요청을 보낼 때의 회전 지연을 줄이기 위해 클라이언트와 서버 사이의 커넥션을 오래 유지하는것을 염두해 두고 있는데, 이때 개인정보의 유출에 악용될 수 있다.
