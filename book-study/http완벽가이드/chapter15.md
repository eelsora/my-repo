# 15. 엔터티와 인코딩

HTTP는 매일 수십억 개의 미디어 객체를 실어 나른다. 또한 아래와같은 것들을 **보장**한다

- **객체는 올바르게 식별되므로 브라우저나 다른 클라이언트는 콘텐츠를 바르게 처리할 수 있다.**
  - `Content-Type` 미디어 포맷과 `Content-Language` 헤더를 이용
- **객체는 올바르게 압축이 풀릴 것이다.**
  - `Content-Length` 와 `Content-Encoding` 헤더를 이용
- **객체는 항상 최신이다.**
  - 엔티티 검사기와 캐시 만료 제어를 이용
- **사용자의 요구를 만족할 것이다.**
  - (내용협상을 위한 `Accept` 관련 헤더들에 기반하여)
- **네트워크 사이를 빠르고 효율적으로 이동할 것이다.**
  - 범위요청, 델타 인코딩, 그외의 데이터 압축을 이용
- **조작되지 않고 온전하게 도착할 것이다.**
  - 전송 인코딩 헤더와 Content-MD5 체크섬 이용

## 15.1 메시지는 컨테이너, 엔터티는 화물

### HTTP 메세지 엔터티는 엔터티 헤더와 본문으로 이루어진다. 헤더와 본문은 빈줄(CRLF)로 나눈다.

HTTP 엔터티 헤더는 HTTP 메세지의 내용물을 설명한다. HTTP/1.1은 다음과 같이 10가지 주요 엔터티 헤더 필드를 정의하였다.

| 헤더 필드        | 설명                                                                                                                                           |
| ---------------- | ---------------------------------------------------------------------------------------------------------------------------------------------- |
| Content-Type     | 엔터티에 의해 전달된 객체의 종류                                                                                                               |
| Content-Length   | 전달되는 메세지의 크기나 길이                                                                                                                  |
| Content-Language | 전달되는 객체와 가장 잘 대응되는 자연어                                                                                                        |
| Content-Encoding | 객체 데이터에 대해 행해진 변형(압축 등)                                                                                                        |
| Content-Location | 요청 시점을 기준으로, 객체의 또 다른 위치                                                                                                      |
| Content-Range    | 만약 이 엔터티가 부분 엔터티라면, 이 헤더는 이 엔터티가 전체에서 어느 부분에 해당하는지 정의한다.                                              |
| Content-MD5      | 엔터티 본문의 콘텐츠에 대한 체크섬                                                                                                             |
| Last-Modified    | 서버에서 이 콘텐츠가 생성 혹은 수정된 날                                                                                                       |
| Expires          | 이 엔터티 데이터가 더 이상 신선하지 않은 것으로 간주되기 시작하는 날짜와 시각                                                                  |
| Allow            | 이 리소스에 대해 어떤 요청 메서드가 허용되는지 (GET, HEAD..)                                                                                   |
| ETag             | 이 인스턴스에 대한 고유 검사기. 엄밀히 말해 ETag 헤더는 엔터티 헤더로 정의되어 있지는 않지만 엔터티와 관련된 많은 동작을 위해 중요한 헤더이다. |
| Cache-Control    | 어떻게 이 문서가 캐시될 수 있는지에 대한 지시자. ETag 헤더와 마찬가지로 Cache-Control 헤더도 엔터티 헤더로 정의되어있지는 않다.                |

### 15.1.1 엔터티 본문

엔터티 본문은 가공되지 않은 데이터만을 담고있다. 다른 정보들은 모두 헤더에 담겨있다.

예를 들어 `Content-Type` 엔터티 헤더는 우리에게 그 데이터(이미지, 텍스트 등)을 어떻게 해석해야 하는지 말해주며, `Conent-Encoding` 엔터티 헤더는 우리에게 그 데이터가 입축되었거나 혹은 추가적인 인코딩이 되었는지 말해준다.

엔터티 본문은 헤더 필드의 끝을 의미하는 빈 CRLF 줄 바로 다음부터 시작한다.

## 15.2 Content-Length: 엔터티의 길이

`Content-Length` 헤더는 메세지의 엔터티 본문의 크기를 바이트 단위로 나타낸다. 어떻게 인코딩 되었든 상관없이 크기를 표현할 수 있다.(gzip으로 압축된 텍스트 파일이라면 원래 크기가 아니라 압축된 후의 크기이다.)

`Content-Length` 헤더는 메세지를 청크 인코딩으로 전송하지 않는 이상, 엔터티 본문을 포함한 메세지에서는 필수적으로 있어야한다. `Content-Length` 헤더는 서버충돌로 인해 메세지가 잘렸는지 감지하고자 할 때와 지속 커넥션을 공유하는 메세지를 올바르게 분할하고자 할 때 필요하다.

### 15.2.1 잘림 검출

예전엔 HTTP 커넥션이 닫힌것을 보고 메세지가 끝났음을 인지하였으나, 이는 정상적으로 닫힌것인지 메세지 전송 중에 서버 충돌이 발생한 것인지 구분하지 못한다.

클라이언트는 메세지 잘림을 검출하기 위해 `Content-Length` 를 필요로한다.

메세지 잘림은 특히 캐싱 프락시 서버에서 취약한데, 잘린 메세지를 캐시하는 위험을 줄이기 위해 캐싱 프락시 서버는 명시적으로 `Conent-Length` 헤더를 갖고있지 않은 HTTP 본문은 캐시하지 않는다

### 15.2.2 잘못된 Content-Length

`Conent-Length`가 잘못된 값을 담고 있을 경우 아예 빠진것 보다도 큰 피해를 유발할 수 있다.

공식적으로 HTTP/1.1 사용자 에이전트는 잘못된 길이를 받고 그 사실을 인지했을 때 사용자에게 알려주게 되어있다.

### 15.2.3 Content-Length와 지속커넥션 (Persistent Connection)

`Conent-Length` 는 지속 커넥션을 위해 필수다. `Conent-Length` 헤더는 클라이언트에게 메세지 하나가 어디서 끝나고 다음 시작은 어디인지 알려준다. 커넥션이 지속적이기 때문에, 클라이언트가 커넥션이 닫힌 위치를 근거로 메세지의 끝을 인식하는 것은 불가능하다.

**청크 인코딩**을 사용할 경우는 `Conent-Length` 헤더 없ㅇ도 엔터티를 잘 정의된 크기의 조각들로 전송할 수 있다.

### 15.2.4 콘텐츠 인코딩

본문 콘텐츠가 인코딩 되어있다면, `Conent-Length` 헤더는 인코딩 되지 않은 원본의 길이가 아닌 인코딩된 본문의 길이를 바이트 단위로 정의한다.

HTTP/1.1 명세에 서술된 어떤 헤더도 인코딩 되지 않은 본문의 길이를 보내기 위해 사용될 수 없는데, 이는 클라이언트가 자신이 수행한 디코딩 과정에 문제가 없었는지 검증하기 어렵게 만든다.

### 15.2.5 엔터티 본문 길이 판별을 위한 규칙

1. 본문을 갖는것이 허용되지 않은 특정 타입의 HTTP 메세지에서는 본문 계산을 위한 `Conent-Length` \*\*\*\*헤더가 무시된다.
   가장 중요한 예는 HEAD응답이다. HEAD 메서드는 GET 요청을 보냈다면 받게될 응답에서 본문은 제외하고 헤더들만 보내라고 서버에 요청한다. GET 응답은 `Conent-Length` 헤더를 돌려주기 때문에 HEAD 응답 또한 그럴 것이다. 그러나 HEAD 응답은 본문을 갖지 않는다. 엔터티 본문을 금하는 메세지는 어떤 헤더 필드가 존재하냐와 상관없이 반드시 헤더 이후 첫번째 빈줄에서 끝나야한다.
2. 메세지가 `Transfer-Encoding` 헤더를 담고있다면 메세지가 커넥션이 닫혀서 먼저 끝나지 않는 이상 엔터티는 ‘0 바이트 청크’라고 불리는 특별한 패턴으로 끝나야한다.
3. `Transfer-Encoding` 헤더를 갖는 메세지를 받았다면 전송 인코딩은 엔터티 본문을 표현하고 전송하는 방식으로 바꿀 것이고, 이 헤더필드가 없다면 `Conent-Length` 헤더 필드의 값은 본문의 길이를 담게 된다.
4. 메세지가 `multipart/byteranges` 미디어 타입을 사용하고 엔터티 길이가 별도로 정의되지 않았다면 (Content-Length 헤더로.), 멀티파트 메세지의 각 부분은 각자가 스스로 크기를 정의할 것이다.
   이 멀티파트 유형은 자신의 크기를 스스로 결정할 수 있는 유일한 엔터티 본문 유형이다.
5. 위의 어떤 규칙에도 해당되지 않는다면, 엔터티는 커넥션이 닫힐 때 끝난다. 실질적으로 오직 서버만이 메세지가 끝났음을 알리기 위해서 커넥션을 닫을 수 있다.
6. HTTP/1.0 애플리케이션과의 호환을 위해 엔터티 본문을 갖고있는 HTTP/1.1 요청은 반드시 유효한 `Conent-Length` 헤더도 갖고 있어야 한다. HTTP/1.1 명세는 요청에 본문은 있지만 Content-Length 헤더는 없는 경우, 메세지의 길이를 판별할 수 없다면 400 Bad Request 응답을 보내고 유효한 Content-Length를 요구하고 싶다면 411 Length Required 응답을 보내라고 조언하고있다.

## 15.3 엔터티 요약

HTTP는 신뢰가는 TCP/IP 전송 프로토콜 위해서 구현되었음에 불구하고, 불완전한 트랜스코딩 프락시나 버그 많은 중개자 프락시를 비롯하여 여러가지 이유로 메시지 일부분이 전송중 변형되는 일이 발생된다.

엔터티 본문 데이터에 대한 의도하지 않은 변경을 감지하기 위해 최초 엔터티가 생성될 때 송신자는 데이터에 대한 체크섬을 생성할 수 있으며, 수신자는 그 체크섬으로 기본적인 검사를 통해 의도한지 않은 엔터티의 변경을 잡아낼 수 있다.

## 15.4 미디어 타입과 차셋(Charset)

`Conent-Length` 헤더 필드는 엔터티 본문의 MIME 타입을 기술한다.

- 흔히 쓰이는 미디어 타입

| 미디어 타입                   | 설명                                                                                          |
| ----------------------------- | --------------------------------------------------------------------------------------------- |
| text/html                     | 엔터티 본문은 HTML 문서                                                                       |
| text/plain                    | 엔터티 본문은 플레인 텍스트 문서                                                              |
| image/gif                     | 엔터티 본문은 GIF 이미지                                                                      |
| image/jpeg                    | 엔터티 본문은 JPEG 이미지                                                                     |
| audio/x-wave                  | 엔터티 본문은 WAV 음향 데이터를 포함                                                          |
| model/vml                     | 엔터티 본문은 삼차원 VRML 모델                                                                |
| application/vnd.ms-powerpoint | 엔터티 본문은 마이크로 소프트 파워포인트 프레젠테이션                                         |
| multipart/byteranges          | 엔터티 본문은 여러부분으로 나뉘는데, 각 부분은 전체 문서의 특정 범위(바이트 단위)를 담고있다. |
| message/http                  | 엔터티 본문은 완전한 HTTP 메세지를 담고있다.                                                  |

`Content-Type` 헤더가 **원본 엔터티 본문의 미디어 타입을 명시**하는것은 중요하다. 예를 들어 엔터티가 콘텐츠 인코딩을 거친 경우에도 `Content-Type` 헤더는 여전히 인코딩 전의 엔터티 본문유형을 명시할 것이다.

### 15.4.1 텍스트 매체를 위한 문자 인코딩

`Content-Type` 헤더는 내용 유형을 더 자세히 지정하기 위한 매개변수도 지원한다.

```html
Content-Type: text/html; charset=iso-8859-4
```

### 15.4.2 멀티파트 미디어 타입

MIME 멀티파트 이메일 메세지는 서로 붙어있는 여러개의 메세지를 포함하며, 하나의 복합 메세지로 보내진다.

각 구성 요소는 자족적으로 자신에 대해 서술하는 헤더를 포함한다.

### 15.4.3 멀티파트 폼 제출

HTTP 폼을 채워서 제출하면, 가변길이 텍스트 필드와 업로드 될 객체는 각각 멀티파트 본문을 구성하는 하나의 파트가 되어 보내진다. 멀티파트 본문은 여러 다른 종류와 길이의 값으로 채워진 폼을 허용한다.

```html
Content-Type: multipart/form-data; boundary=abcdefg --abcdefg
Content-Diposition: form-data; name="submit-name" Sally --abcdefg
Content-Diposition: form-data; name="files"; filename="essayfile.txt"
Content-Type: text/plain ...contents of essayfile.txt... --abcdefg--
```

이 때 boundary는 본문의 서로 다른 부분을 구분하기 위한 구분자로 쓰인다.

```html
Content-Type: multipart/mixed; boundary=my_unique_boundary_string
--my_unique_boundary_string Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: quoted-printable 안녕하세요! 이것은 multipart/mixed
메시지의 첫 번째 파트입니다. 일반 텍스트 데이터가 들어 있습니다. 특수 문자도 잘
인코딩됩니다: =EC=95=88=EB=85=95! --my_unique_boundary_string Content-Type:
image/jpeg Content-Transfer-Encoding: base64 Content-Disposition: attachment;
filename="example.jpg"
/9j/4AAQSkZJRgABAQEAYABgAAD/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0a
HBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgyPC4zNDL/2wBDAQoLCwsNDw4NDw4NFhANCgsLDAwL
DAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwL/wAARCAAwADAD
AREAAhEB/8QAGQAAAgMBAAAAAAAAAAAAAAAABAUAAwYH/8QAMBAAAgEDAgQDBwUAAAAAAAABAgME
AAURBhIHEyExQSJRYXGBkaEUMkJSYoLB/8QAGwEAAgMBAQEAAAAAAAAAAAAAAAMBAgQFBgf/xAAt
EQACAQIEBAUEAwAAAAAAAAABAgADEQQFIUESMVEGEzJhcYEiQqFSgaGx0f/aAAwDAQACEQMRAD8A
6iysLq9tIbi3hkaOZQyFegp4Nq+G3t/K/wCzI3/hG5oK7T9T1LS702+oRSxRscCRc4Yfj3rCqPZ
vB2k+1tC+v3H9e3H9I3P6e1Z3cE+8x+I/M+Z3d/K/wCzI3/hG5oM7uF/wCzI3/hG5oM7uF/wCz
I3/hG5oM7uF/wCzI3/hG5pBnu4X/syN/wCAbmgzu4X/ALMj/wDAo3NBndwv/Zkf/gG5p+Gj7fD
d/K/wCzI3/hG5oO7vB2k+1tC+v3H9e3H9I3P6e1WJc1h7R8L2mp6fHf20UsUMqhhIucr+PatrZ
xXq2sc+0o3/hG5oA13cQ/wB2Rv8Awjc0B3cQ/wB2Rv/CNzQHdxD/dkb/wjc0B3cQ/3ZG/8I3NA
F3cQ/wB2Rv/CNzQHdxD/AHZG/w8zc0B3cQ/3ZG/8I3NAF3cQ/wB2Rv8AwD/mgD+E/9k=
--my_unique_boundary_string--
```

### 15.4.4 멀티파트 범위 응답

다른 범위에 대한 응답 또한 멀티파트가 될 수있다.

## 15.5 콘텐츠 인코딩

HTTP 애플리케이션은 때때로 콘텐츠를 보내기 전에 인코딩을 하려한다. 전송시간을 줄이기휘함, 허가받지 않은 제삼자가 볼 수없도록 암호화 등의 이유가 있을 수 있다.

### 15.5.1 콘텐츠 인코딩 과정

1. 웹 서버가 원본 `Content-Type`과 `Content-Length` 헤더를 수반한 원본 응답 메세지를 생성한다.
2. 콘텐츠 인코딩서버(아마 원 서버거나 다운스트림 프락시일것임)가 인코딩된 메세지를 생성한다.
   인코딩된 메세지는 `Content-Type`은 같지만 (본문이 압축되었거나 했다면) `Content-Length` 는 다르다.
   콘텐츠 인코딩 서버는 `Content-Encoding` 헤더를 인코딩된 메세지에 추가하여 수신측 애플리케이션이 그것을 디코딩할 수 있도록 한다.
3. 수신측 프로그램은 이코딩도니 메세지를 받아서 디코딩하고 원본을 얻는다.

### 15.5.2 콘텐츠 인코딩 유형

HTTP는 몇가지 표준 콘텐츠 인코딩 유형을 정의하고 확장 인코딩으로 인코딩을 추가하는것도 허용한다.

- 흔히 쓰이는 콘텐츠 인코딩 토큰 (이중 gzip이 일반적으로 가장 효율적이고 널리 쓰이는 압축알고리즘임)

| 콘텐츠 인코딩 값                                                 | 설명                                                                     |
| ---------------------------------------------------------------- | ------------------------------------------------------------------------ |
| gzip                                                             | 엔터티에 GNU zip 인코딩이 적용되었음을 의미                              |
| compress                                                         | 엔터티에 대해 유닉스 파일 압축 프로그램인 ‘compress’가 실행되었음을 의미 |
| deflate                                                          | 엔터티가 zilb 포맷으로 압축되었음을 의미                                 |
| identity                                                         | 엔터티에 어떤 인코딩도 수행되지 않았음을 의미.                           |
| Content-Encoding 헤더가 존재하지 않는다면 이 값인 것으로 간주함. |

### 15.5.3 Accept-Encoding 헤더

서버에서 클라이언트에서 지원하지 않는 인코딩을 사용하는것을 방지하기 위해 클라이언트는 `Accept-Encoding` 요청헤더를 통해 원하는 인코딩 목록을 헤더로 전달한다.

헤더에 포함하지 않는다면 어떤 인코딩이든 허용한다는 뜻(\* 도 같은 의미)

```html
Accept-Encoding: compress, gzip Accept-Encoding: Accept-Encoding: *
Accept-Encoding: gip;z-1.0, identity; q-0.5, *;q=0
```

## 15.6 전송 인코딩과 청크 인코딩

콘텐츠 인코딩은 콘텐츠 포맷과 긴밀하게 연관되어있다. 예를 들어 텍스트 파일은 흔히 gzip으로 압축하지만 JPEG 파일은 gzip으로 잘 압축되지 않기 때문에 그렇게 하지 않는다.

콘텐츠 인코딩된 메세지는 단지 메세지의 엔티티 부분만 인코딩한다. 전송 인코딩된 메세지에서는 인코딩은 전체 메세지에 대해 적용되어 메세지 자체의 구조를 바꾼다.

### 15.6.1 안전한 전송

역사적으로 전송 인코딩은 다른 프로토콜에서도 네트워크를 통한 ‘안전한 전송’을 위해 존재했다. 표준화되고 더 너그러운 전송 기반을 갖춘 HTTP는 ‘안전한 전송’의 초점을 다른데 맞추고 있다.

- **알수없는 크기**
  - 일부 서버나 콘텐츠 인코더는 콘텐츠의 전체 크기를 미리 알 수 없기 때문에, `Content-Length`를 지정하지 못하고 데이터를 바로 전송해야 하는 경우가 있다. 이럴 때 HTTP에서는 특별한 종결 표시(예: 청크 전송 인코딩)를 사용해 데이터의 끝을 알린다.
- **보안**
  - 전송 인코딩을 이용해 메시지를 난독화할 수는 있지만, SSL 같은 전송 계층 보안 방식이 이미 널리 사용되기 때문에 이런 방식은 드물다.

### 15.6.2 Transfer-Encoding 헤더

전송 인코딩을 제어하고 서술하기 위해 정의된 헤더는 단 두개 뿐이다.

- **Transfer-Encoding**
  - 안전한 전송을 위해 어떤 인코딩이 메세지에 적용되었는지 수신자에게 알려준다.
    - **역할:** HTTP 메시지 본문(Body)을 **전송할 때의 인코딩 방식**을 지정합니다.
    - **예시:** `chunked`, `compress`, `deflate`, `gzip` 등이 있음
    - **주로 사용되는 경우:** 콘텐츠의 전체 크기를 알 수 없을 때, `Content-Length` 대신 사용
    - **대표 예시:**
      ```
      Transfer-Encoding: chunked
      ```
    - **chunked 인코딩**: 데이터를 일정한 크기의 청크로 나눠 전송하고, 마지막에는 `0\r\n\r\n`으로 끝을 표시함
    - **중요한 점:**
      - `Transfer-Encoding`은 **요청 또는 응답** 모두에 사용될 수 있지만, **응답에서 더 흔하게 사용됨**
      - `Content-Length`와 **동시에 사용할 수 없음** (HTTP/1.1 명세에서 충돌함)
- **TE**
  - 어떤 확장된 인코딩을 사용할 수 있는지 서버에 알려주기 위해 요청헤더에 사용한다.
    - **역할:** 클라이언트가 서버에 **어떤 전송 인코딩을 수용할 수 있는지**를 알려줌
    - **즉:** "나는 이런 인코딩을 이해할 수 있어요"라는 신호
    - **예시:**
      ```
      TE: chunked
      TE: gzip, deflate; q=0.5
      ```
    - `q=값`은 선호도(quality)를 의미 (`1.0`이 가장 선호)
    - `TE` 헤더는 **클라이언트 → 서버** 요청 헤더에만 사용됨
    - 서버는 이 정보를 바탕으로 인코딩 방식을 선택할 수 있음

### 15.6.3 청크 인코딩

청크 인코딩은 메시지 본문을 작은 조각(청크)으로 나눠 순차적으로 전송하는 방식으로, 전체 크기를 미리 알 필요 없이 동적으로 데이터를 전송할 수 있게 해준다. 이는 본문 내용이 아니라 메시지 전송 방식(전송 인코딩)에 해당된다.

- **청크와 지속 커넥션**
  - 청크 인코딩은 본문이 동적으로 생성되며 그 중 일부를 버퍼에 담은 뒤 그 한 덩어리를 그의 크기와 함께 보낼 수 있다. 본문을 모두 보낼 때 까지 이 단계를 반복한다. 서버는 크기가 0인 청크로 본문이 끝났음을 알리고 다음 응답을 위해 커넥션을 열린채로 유지할 수 있다.
    - 마지막 청크는 `0\r\n\r\n`으로 끝을 알림
    - **동적으로 생성되는 데이터**도 전송 가능
    - 전체 응답 길이를 미리 계산하지 않아도 됨
  - 지속 커넥션은 본문을 쓰기 전에 반드시 `Content-Length` 헤더에 본문 길이를 담아 보내줘야한다.
  - **청크 인코딩은 지속 커넥션을 효과적으로 사용하기 위해 유용함**
  - 예: 서버가 콘텐츠 길이를 모른 채 데이터를 보내면서도 **연결을 끊지 않고** 계속 유지할 수 있음
- **청크 인코딩된 메세지의 트레일러**
  트레일러는 청크 인코딩 메시지 끝에 붙는 추가 헤더로, 본문 전송 후에야 알 수 있는 정보를 담는다. 본문을 모두 보낸 뒤에야 알 수 있는 정보(예: `Content-MD5`, `Expires`)를 전송할 때 사용된다.
  - 아래 조건을 하나 이상 만족하면 청크 메세지에 트레일러를 추가할 수 있다
    - 클라이언트의 TE 헤더가 트레일러를 받아들일 수 있음을 나타내고 있는 경우
    - 트레일러가 응답을 만든 서버에 의해 추가되었으며, 그 트레일러의 콘텐츠는 클라이언트가 이해하고 사용할 필요가 없는 선택적인 메타데이터 이므로 클라이언트가 무시하고 버려도 되는경우

### 15.6.4 콘텐츠와 전송 인코딩의 조합

콘텐츠 인코딩과 전송 인코딩은 동시에 사용될 수 있다. 클라이언트는 **전송 해제 → 콘텐츠 해제** 순서로 처리함.

- **동작 순서**
  1. 서버:
     - 콘텐츠를 압축 (`Content-Encoding`)
     - 압축된 데이터를 청크로 나눔 (`Transfer-Encoding`)
  2. 클라이언트:
     - 먼저 청크 인코딩 해제 (`Transfer-Encoding`)
     - 그 다음 압축 해제 (`Content-Encoding`)

### 15.6.5 전송 인코딩 규칙

메세지 본문을 네트워크로 전송할 때 인코딩 방식을 정의하는데, 이를 사용할때 따라야할 몇가지 규칙이 있다.

1. 전송 인코딩의 집합은 반드시 ‘chunked’를 포함해야한다. 유일한 예외는 메세지가 커넥션의 종료로 끝나는 경우이다.
2. 청크 전송 인코딩이 사용되었다면, 메세지 본문에 적용된 마지막 전송 인코딩이 존재해야한다.
3. 청크 전송 인코딩은 반드시 메세지 본문에 한번 이상 적용되어야 한다.

## 15.7 시간에 따라 바뀌는 인스턴스

HTTP는 객체 인스턴스를 다루는 방식(=인스턴스 조작)을 정의하며, 대표적으로 범위 요청과 델타 인코딩이 있다.

이들은 클라이언트가 가진 리소스 사본과 서버의 것이 동일한지 판단하고, 필요시 새 인스턴스를 요청할 수 있도록 한다.

## 15.8 검사기와 신선도

클라이언트가 서버에게 자신이 갖고 있는 버전을 말해주고 검사기를 이용해 자신의 사본 버전이 더이상 유효하지 않을 때만 사본을 보내달라고 요청한다.

### 15.8.1 신선도

서버는 `Expires`나 `Cache-Control` 헤더를 통해 클라이언트에게 얼마나 오랫동안 콘텐츨를 캐시하고 그것을 신선하다고 가정할 수 있는지에 대한 정보를 준다.

- `Expires`: 문서가 만료되어 더이상 신선하다고 간주할 수 없게되는 정확한 날짜 명시. 클라이언트와 네트워크 시간 프로토콜을 반드시 동기화 해놓아야 양쪽 시간을 올바르게 정의하여 사용할 수 있다.
- `Cache-Control`: 문서의 최대 수명을 문서가 서버를 떠난 후로부터의 총 시간을 초 단위로 정한다. 수명은 시계 동기화에 의존하지 않으므로 더 정확한 결괄를 말해준다.
  - **헤더 지시자 종류**
    - **캐시 허용 범위**: `public`, `private`, `no-store`, `no-cache`
    - **만료 시점**: `max-age`, `s-maxage`, `max-stale`, `min-fresh`
    - **재검사 정책**: `must-revalidate`, `proxy-revalidate`
    - **기타 동작 최적화**: `immutable`, `only-if-cached`, `stale-while-revalidate`, `stale-if-error`

### 15.8.2 조건부 요청과 검사기

조건부 요청은 ‘If-’로 시작하는 조건부 헤더에 의해 구현된다. 조건부 헤더는 조건이 참일 때에만 수행되도록 하며 참이 아니면 HTTP 에러코드를 돌려보낸다

```html
GET /announce.html HTTP/1.0 If-Modified-Since: Sat, 29 Jun 2002, 14:30:00 GMT
```

| 요청 헤더             | 응답 조건                                            | 의미                                                     |
| --------------------- | ---------------------------------------------------- | -------------------------------------------------------- |
| `If-Modified-Since`   | 리소스가 **지정한 날짜 이후에 변경되었을 때만** 응답 | 서버 리소스의 `Last-Modified` 값과 비교                  |
| `If-Unmodified-Since` | **지정 시간 이후에 변경되지 않았을 때만** 수행       | 오래된 버전으로 덮어쓰지 않기 위해                       |
| `If-Match`            | 지정한 ETag와 **일치할 때만** 요청 수행              | 리소스가 변경되지 않았을 때만 수정 허용 (예: PUT, PATCH) |
| `If-None-Match`       | 리소스의 ETag가 **다를 때만** 응답                   | ETag 기반 비교                                           |

ETag 헤더는 매 변경마다 구분되는 값을 넣어두기 때문에 강한 검사기로 간주한다.

## 15.9 범위 요청

HTTP 범위 요청(HTTP Range Request)은 클라이언트가 **리소스의 일부분만 요청할 수 있도록 하는 HTTP 기능**입니다. 주로 **대용량 파일 다운로드, 미디어 스트리밍, 다운로드 재개 기능** 등에 활용된다.

`Accept-Ranges`는 **HTTP 응답 헤더**로, 서버가 클라이언트의 범위 요청(Range Request)을 지원하는지 여부를 명시한다.

![image.png](attachment:8e7a0341-3d45-485b-928b-33d3990b8feb:image.png)

| 단계 | 설명                                 |
| ---- | ------------------------------------ |
| 1    | 클라이언트가 리소스를 요청           |
| 2    | 서버가 범위 요청 가능 여부를 알려줌  |
| 3    | 클라이언트가 특정 바이트 범위를 요청 |
| 4    | 서버가 해당 범위의 데이터만 응답     |

## 15.10 델타 인코딩

델타 인코딩은 객체 전체가 아닌 변경된 부분에 대해서만 통신하여 전송량을 최적화하는, HTTP 프로토콜의 확장이다. 델타 인코딩은 일종의 인스턴스 조작인데 왜냐하면 어떤 객체의 특정 인스턴스들에 대한 클라이언트와 서버 사이의 정보 교환에 의존하기 때문이다.

| 헤더 이름       | 방향           | 설명                                                                                          |
| --------------- | -------------- | --------------------------------------------------------------------------------------------- |
| `A-IM`          | 요청(Request)  | 클라이언트가 지원하는 인스턴스 조작 방식(예: `delta`)을 서버에 알림                           |
| `If-None-Match` | 요청(Request)  | 클라이언트가 보유한 리소스의 ETag(버전)을 서버에 전달하여, 변경 여부 확인 또는 델타 기준 지정 |
| `ETag`          | 응답(Response) | 서버가 리소스에 대해 발급한 고유 버전 식별자                                                  |
| `IM`            | 응답(Response) | 서버가 실제 사용한 인스턴스 조작 방식 명시 (예: `delta`)                                      |
| `Delta-Base`    | 응답(Response) | 응답된 델타 데이터가 어떤 `ETag` 버전 기준으로 생성되었는지 명시                              |

### 15.10.1 인스턴스 조작, 델타 생성기 그리고 델타 적용기

- **인스턴스 조작**은 HTTP 리소스의 버전(인스턴스)을 기준으로 읽고 비교하거나 델타를 적용하는 일련의 동작
- HTTP에서는 `ETag`, `If-None-Match`, `Delta-Base` 등의 헤더가 이 조작 흐름을 지원
- 클라이언트와 서버는 이 과정을 통해 **불필요한 전체 전송을 줄이고**, **변경된 부분만 효율적으로 관리**할 수 있음
