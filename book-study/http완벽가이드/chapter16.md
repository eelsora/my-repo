# 16. 국제화

## 16.1 국제적인 콘텐츠를 다루기 위해 필요한 HTTP 지원

HTTP메세지는 어떤 언어로된 콘텐츠든, 이미지, 동영상 등처럼 미디어처럼 실어 나를 수있다.

HTTP에서 엔터티 본문이란 그저 비트들로 가득 찬 상자에 불과하다.

국제 콘텐츠를 제공하기 위해 서버는 클라이언트에게 HTTP Content Type chartset 매개변수와 Content-Language 헤더를 통해 문서의 문자와 언어를 알려주어 올바를 콘텐츠를 제공할 수 있도록 한다.

```html
Accept-Language: fr, en;q=0.8 Accept-Charset: iso-8859-1, utf-8
```

## 16.2 문자집합과 HTTP

### 16.2.1 차셋(Charset)은 글자를 비트로 변환하는 인코딩이다

HTTP 차셋 값은 어떻게 엔터ㄷ티 콘텐츠 비트들을 특정 문자 체계의 글자들로 바꾸는지 알려준다.

- `Content-Type: text/html; charset=iso-8859-6`
  → 콘텐츠가 HTML 파일임을 말해주고, chartset 매개변수는 콘텐츠 비트들을 글자들로 디코딩 하기 위해 iso-8859-6 디코딩 기법을 사용하라고 말해준다.

### 16.2.2 문자집합과 인코딩은 어떻게 동작하는가

1. 인코딩 구조(iso-8859-6)를 사용하여 디코딩
2. 코딩된 문자집합을 사용하여 글자를 찾는다.
3. 글꼴과 포매팅 소프트웨어를 사용하여 화면이 보여줄 모양을 찾는다.

→ HTTP ‘문자 집합’은 문자 인코딩 구조와 코딩된 문자집합을 결합한것이다.

### 16.2.3 잘못된 차셋은 잘못된 글자들을 낳는다

만약 클라이언트가 잘못된 charset 매개변수를 사용한다면, 클라이언트는 이상한 깨진 글자를 보여주게 된다.

### 16.2.4 표준화된 MIME 차셋 값

특정 문자 인코딩과 특정 코딩된 문자집합의 결합을 MIME 차셋이라고 부른다. HTTP는 표준화된 차셋 태그를 `Content-Type` 과 `Accept-Charset` 헤더에 사용한다.

- 등록된 차셋 값들의 목록: http://www.iana.org/numbers.html

### 16.2.5 Content-Type charset 헤더와 META태그

- `Content-Type: text/html; charset=iso-2022-jp`

웹 서버는 클라이언트에게 MIME 차셋 태그를 charset 매개변수와 함께 `Content-Type` 헤더에 담아 보낸다.

만약 문자집합이 명시적으로 나열되지 않았다면 수신자는 문서 콘텐츠로부터 문자집합을 추측하려 시도한다. 만약 클라이언트가 문자 인코딩을 추측하지 못했다면 iso-8859-1인것으로 가정한다.

```html
<head>
  **
  <meta http-equiv="Conent-Type" content="text/html; charset=iso-2022-jp" />
  ** **
  <meta lang="jp" />
  ** ...
</head>
```

### 16.2.6 Accept-Charset 헤더

HTTP 클라이언트는 서버에게 Accept-Charse 헤더값을 통해 클라이언트가 지원하는 문자 인코딩의 목록을 제공한다.

`Accept-Charset: iso-8599-1, utf-8`

Accept-Charset 요청 헤더에 대응하는 Content-Charset응답헤더는 존재하지 않는다! 응답 문자 집합은 MIME과의 호환을 위해 Content-Type 응답 헤더의 charset 매개변수를 통해 서버로부터 돌려받는다.

## 16.3 다중언어 문자 인코딩에 대한 지침

### 16.3.1 문자집합 용어

- **문자:** 알파벳, 글자, 숫자, 구두점, 표의문자(중국어에서와 같은), 기호 등 글쓰기의 최소단위.
- **글리프(glyph):** 하나의 글자를 표현하기 위한, 획의 패턴이나 다른것과 구분되는 유일한 시각적 형태
- **코딩된 문자(coded character):** 우리가 글자를 다룰 수 있도록 각 글자에 할당된 유일한 숫자
- **코드공간(coding space):** 문자 코드값으로 사용하려고 계획해 둔 정수의 범위
- **코드너비(code width):** 각 문자 코드의 (고정된 크기의) 비트 개수 \*\*\*\*
- **사용 가능 문자집합(character repertoire):** 글자들에 대한 특정한 작업집합
- **코딩된 문자 집합(coded character set):** 사용 가능 문자집합을 받아서 각 글자에 코드 공간의 코드를 할당해주는 코딩된 문자들의 집합. 실제 글자들에 숫자로 된 문자 코드를 대응시킨 것이다.
- **문자 인코딩 구조:** 숫자로된 문자 코드들을 콘텐츠 비트의 연속으로 인코딩하는 알고리즘

### 16.3.2 ‘차셋(Charset)’은 형편없는 이름이다

MIME 차셋 값은 데이터 비트를 고유한 문자의 코드로 매핑하는 알고리즘의 이름이다. 이것은 문자 인코딩 구조와 코딩된 문자집합의 개념을 합친것이다.

### 16.3.3 문자

문자는 쓰기의 기본적인 구성요소이다. 하나의 문자는 하나의 알파벳 글자, 숫자, 구두점, 표의문자 등 다른 쓰기의 기본 단위를 표현한다.

### 16.3.4 글리프(glyphs), 연자(ligatures) 그리고 표현 형태

글리프와 문자를 헷갈려서는 안된다. 문잦는 유일하고 추상화된 언어 요소이고 그리프는 각 글자를 그리는 특정한 방법이다. 각 문자는 미적인 양식과 스크립트에 따라 여러가지 글리프를 가진다.

### 16.3.5 코딩된 문자 집합(Coded Character Set)

- US-ASCII: 모든 문자 집합의 어머니
- iso-8859: US-ASCII의 8비트 확대 집합들
- JIS X 0201: 아스키를 일본어 가타카나 반각문자를 더해 확장한 극단적으로 작은 문자집합
- JIS X 0208과 JIS X 0212
  - JIS X 0208: 최초의 멀티바이트 일본어 문자집합. 대부분이 일본식 한자인 6879개의 코딩된 문자를 정의함.
  - JIS X 0212는 6607개 문자 추가
    - UCS: 국제 문자세트(Universal Character Set)전 세계의 모든 글자를 코딩된 문자집합으로 통합하려 노력하는 세계적인 표준

### 16.3.6 문자 인코딩 구조

- 고정폭: 각 코딩된 문자를 고정된 길의의 비트로 표현한다. 빠르게 처리되지만 공간 낭비 우려가있음.
- 가변폭(비모달): 다른 문자 코드 번호에 다른 길이의 비트를 사용함. 자주 사용하는 글자의 비트 길이를 줄일 수 있고, 국제 문자에 대해서는 여러 바이트를 사용하도록 함으로써 이전의 8비트 문자집합과의 호환성도 유지할 수 있음.
- 가변폭(모달): 모달 인코딩은 달나ㅡ 모드로의 전환을 위해 특별한 ‘escape’패턴을 사용함. 예를 들어 어떤 모달 인코딩은 텍스트에서 중첩된 여러가지 문자 집합간의 전환을 위해 사용될 수 있다. 모달 인코딩은 복잡하지만 복잡한 표기 체계를 효과적으로 지우넣재루 수 있다.
- 8비트: 8비트 고정폭 아이덴티티 인코딩은 간단히 각 문자코드를 그에 댛응하는 8비트값으로 인코딩한다. 256개의 문자의 코드 범위에 대한 문자집ㅎ팝만을 지원한다. iso-8859문자 집합군은 8비트 아이덴티티 인코딩을 사용한다.
- UTF-8: 가장 인기있는 UCS(UCS Transformation Format)를 위해 설계된 문자 인ㅋ됭. 문자 코드의 값을 위해 비모달 가변길이 인코딩을 사용한다.
- iso-2022-jp: 일본어 인터넷 문서를 위해 널리 사용되는 인코딩 8비트 문자를 지원하지 않는 소프트웨어와의 문제점을 방지하기 위해 128보다 작은 값으로만 이루어진 가변길이 모달 인코딩이다.
- euc-jp: 인기있는 일본어 인코딩. EUC는 ‘Extended Unix Code’의 약자로 유닉스 운영체제에서 아시아 문자들을 지원하기 위해 처음 개발됨.
- euc-kr: 한글 인터넷 문서를 위해 널리 사용되는 가변길이 인코딩

## 16.4 언어태그와 HTTP

언어태그는 언어에 이름을 붙이기 위한 짧고 표준화된 문자열이다. (en, ko,de, pt-BR, en-US ….)

### 16.4.1 Content-Language

Content-Language 엔터티 헤더 필드는 엔터티가 어떤 언어 사용자를 대상으로 하고 있는지 서술한다.

- `Content-Language: fr` : 프랑스어 사용자를 대상으로함을 의미

### 16.4.2 Accept-Language 헤더

- `Accept-Language: es` : 스페인어로된 콘텐츠에 대한 클라이언트 요청

### 16.4.3 언어 태그의 종류

- 일반적인 언어의 종류 (스페인어를 의미하는 ‘es’와 같이)
- 특정 국가의 언어 (영국 영어를 의미하는 ‘en-GB’와 같이)
- 방언 (노르웨이어의 ‘Book Language’를 의미하는 ‘no-bok’과 같이)
- 지방어 (마서스 비니어드 섬의 수화를 의미하는 ‘sgn-US-MA’)
- 그외의, 다른 언어의 변형이 아닌 표준 언어 (예: ‘i-navajo’)
- 비표준 언어 (예: ‘x-snowboarder-slang’)

### 16.4.4 서브태그

주 서브태그는 오직 A-Z 까지의 글자만 포함하고, 다음 서브태그는 알파벳이나 숫자를 포함할 수 있으며 최대 8자까지 가능하다.

- sng-US-MA
  - `sng`: 첫번째 서브태그. 주 서브태그라고 불린다. 이 값들은 표준화 되어있다.
  - `US` : 두번째 서브태그. 선택적이고 자신만의 이름 표준을 따른다.
  - `MA` : 세번째 서브태그. 등록되어있지않다.

### 16.4.5 대소문자의 구분 및 표현

모든 태그는 대소문자가 구분되지 않는다. ‘en’과 ‘eN’은 같다.

관용적으로 언어를 나타낼때에는 소문자를 사용하고, 국가를 나타낼 때에는 대문자를 사용한다.

- ‘fr’은 프랑스어로 분류되는 언어를 의미하고 ‘FR’은 국가인 프랑스를 의미한다.

### 16.4.6 IANA 언어 태그 등록

첫번째와 두번째 언어 서브태그의 값은 여러가지 표준문서와 그것들을 관리하는 조직에 의해서 정의된다. IANA는 RFC3066의 규칙에 따라 표준 언어 태그의 목록을 관리한다.

만약 언어태그가 표준 국가와 언어의 조합이라면, 그 태그는 굳이 등록되지 않아도 되며 표준 국가와 언어값으로 구성될 수 없는 언어 태그들만이 등록될 필요가 있다.

### 16.4.7 첫번째 서브태그: 이름공간

첫번째 서브태그는 보통 ISO 639 표준 언어집합에서 선택된 표준화된 언어 토큰이다.

- 만약 첫번째 서브 태그가
  - 두글자라면 ISO 639 와 639-1 표준의 언어 코드이다.
  - 세글자라면 ISO 639-2 표준과 확장에 열거된 언어코드이다
  - 글자 ‘i’라면 이 언어는 틀림없이 IANA에 등록된 것이다
  - 글자 ‘x’라면 이 언어 태그는 특정 개인이나 집단 전용의 비표준확장 서브태그다.

### 16.4.8 두번째 서브태그: 이름공간

두번째 서브태그는 보통 ISO 3166 국가코드와 지역 표준집합에서 선택된 표준화된 국가토큰이다. 그러나 IANA에 등록된 다른 문자열일 수도 있다.

- 두번째 서브태그는
  - 두 글자라면 ISO 3166에 정의된 국가/지역이다.
  - 3~8 글자라면 IANA에 등록된 것이다.
  - 한글자라면 뭔가 잘못된것이다.

### 16.4.9 나머지 서브태그: 이름공간

세번째와 그 이후의 서브태그에 대해서는 8자 이하의 알파벳과 숫자로 이루어져야한다는것을 제외하면 다른 규칙은 없다.

### 16.4.10 선호 언어 설정하기

웹 브라우저 프로필에서 선호 언어를 설정할 수 있음

### 16.4.11 언어 태그 참조표

… 책 부록에 참조표 제공함

## 16.5 국제화된 URI

오늘날 URI는 국제화를 그다지 지원하지 않는다. 몇가지 예외와 함께, 오늘날의 URI는 US-ASCII의 부분집합으로 구성되어있다.
(최신 명세인 RFC 3986은 URI에 UTF-8 문자를 사용할 수 있는 방ㅂ넙을 명시적으로 제시하고 있음.)

### 16.5.1 국제적 가독성 vs 의미있는 문자들

URI 저자들은 리소스 식별자의 가독성과 공유 가능성의 보장이, 대부분의 의미있는 문자들로 구성될 수 있도록 하는것 보다 더 중요하다고 여겨서 ASCII 문자들의 제한된 집합으로 이루어진 URI를 갖게 되었다.

### 16.5.2 URI에서 사용될 수 있는 문자들

URI에서 사용할 수 있는 US-ASCII 문자들의 부분집합은 예약된 문자들, 예약되지 않은 문자들, 이스케이프 문자들로 나뉜다. 예약되지 않은 문자들은 그것들을 허용하는 URI의 어떤 구성요소에서든 일반적으로 사용될 수 있다. 예약된 문자들은 많은 URI에서 특별한 의미를 가지며 일반적으로 사용될 수 없다.

| 문자 분류     | 사용 가능 문자집합                                |
| ------------- | ------------------------------------------------- |
| 예약되지 않음 | `[A-Za-z0-9]` `-` `_` `.` `!` `~` `*` `"` `(` `)` |
| 예약됨        | `;` `/` `?` `:` `@` `&` `=` `+` `$` `,`           |
| 이스케이프    | `%` `<HEX>` `<HEX>`                               |

### 16.5.3 이스케이핑과 역이스케이핑(unescaping)

이스케이프는 퍼센트글자 (%) 하나와 뒤이은 16진수 글자둘로 이루어진 세글자 문자열이다. 예를들어 URL에 스페이스(아스키32)를 삽입하고싶다면 이스케이ㅠ프 ‘%20’을 사용할 수 있다.(20은 32의 16진법 표현).

URI를 해석할때 이스케이핑된 코드 바이트들은 원래의 ASCII 코드 바이트로 변환된다. 내부적으로 HTTP 애플리케이션은 URI를 데이터가 필요할 때만 언어스케이핑 해야한다. 그리고 어떤 URI도 결코 두번 언어 스케이핑되지 않도록 해야한다.!!! - > 데이터 손실을 유발함

### 16.5.4 국제 문자들을 이스케이핑하기

이스케이프 값들은 US-ASCII 코드의 범위(0-127)에 있어야함에 주의해야한다.
어떤 어플리케이션은 iso-8859-1 확장 문자들 (128-255)를 표현하기 위해 이스케이프값을 사용하려한다. 예를 들어 웹서버는 국제 문자를 포함한 파일 이름을 부호화하기위해 이스케이핑을 오용했을 수도 있는데 이는 부정확하며 어떤 어플리케이션에서는 문제를 유발할 수 있다.

### 16.5.5 URI에서의 모달 전환

URI는 그다지 국제화에 친화적이지 않고, URI 이식성의 목표는 언어 유연의 목표보다 중요했다.

(오늘날은 ASCII 범위 밖의 문자를 인코딩 하는일은 흔해짐)

## 16.6 기타 고려사항

### 16.6.1 헤더와 명세에 맞지 않는 데이터

HTTP헤더는 반드시 US-ASCII 문자 집합의 글자들로만 이루어져야 한다. 그러나 모든 클라이언트와 서버가 이를 올바르게 구현한 것은 아니므로, 때때로 127보다 큰 코드 값을 갖는 잘못된 문자를 받게될 수도 있다.

### 16.6.2 날짜

HTTP 명세는 올바른 GMT 날짜 형식을 명확히 정의하고 있지만 모든 웹서버와 클라이언트가 규칙을 따르고 있지 않음을 주의해야한다.

HTTP 애플리케이션은 명세에 맞지 않는 날자를 받아들이며 충돌을 일으키지 말아야한다.

### 16.6.3 도메인 이름

국제화 문자를 포함하는 도메인 이름을 ‘국제화 도메인 이름(Internationalizing Domain Name)’이라고 하는데, 오늘날 대부분의 웹브라우저가 퓨니코드(punycode)를 이용해 이를 지원한다. 퓨니코드란 유니코드 문자열을 호스트명에서 사용 가능한 문자만으로 이루어진 문자열로 변환하는 방법으로 RFC3492에 정의되어있다.

웹 브라우저들은 이 기법으 ㄹ이용해 사용자가 입력한 다국어로 된 도메인을이름을 알파벳과 숫자 등으로된 도메인 이름으로 변환한다. 예를 들어 ‘한글.com’은 ‘xn—bj0bj06e.com’으로 변환한다.
