# 11. 클라이언트 식별과 쿠키

## 11.1 개별 접촉

HTTP는 익명으로 사용하며 상태가 없고, 요청과 응답으로 통신하는 프로토콜이다. (stateless 프로토콜)

## 11.2 HTTP 헤더

| 헤더 이름                                            | 헤더 타입  | 설명                                     |
| ---------------------------------------------------- | ---------- | ---------------------------------------- |
| From                                                 | 요청       | 사용자의 이메일 주소                     |
| User-Agent                                           | 요청       | 사용자의 브라우저                        |
| Referer                                              | 요청       | 사용자가 현재 링크를 타고 온 근원 페이지 |
| (사용자가 현재 페이지로 유입하게 한 웹 페이지의 URL) |
| Authorization                                        | 요청       | 사용자 이름과 비밀번호                   |
| Client-ip                                            | 확장(요청) | 클라이언트 IP주소                        |
| X-Forwarded-For                                      | 확장(요청) | 클라이언트 IP주소                        |
| Cookie                                               | 확장(요청) | 서버가 생성한 IP 라벨                    |

## 11.3 클라이언트 IP 주소

클라이언트 IP주소는 보통 HTTP 헤더에 없지만, 웹 서버는 HTTP 요청을 보내는 반대쪽 TCP 커넥션의 IP 주소를 알아낼 수 있다.

**클라이언트 IP 주소로 식별하는 방식의 약점**

- 클라이언트 IP 주소는 사용자가 아닌 사용하는 컴퓨터를 가리키기 때문에 여러 사용자가 같은 컴퓨터를 사용하면 사용자를 식별할 수 없다.
- 많은 인터넷 서비스 제공자(ISP)는 사용자가 로그인하면 동적으로 IP주소를 할당하기 때문에 웹 서버는 사용자를 IP로 식별할 수 없다.
- 많은 사용자가 보안을 위해 NAT(Network Address Translation)방화벽을 통해 인터넷을 사용한다. 이 장비들은 실제 IP를 뒤로 숨기고 하나의 방화벽 IP주소로 변환한다.
- 보통 HTTP 프락시와 게이트웨이는 원 서버에 새로운 TCP를 연결한다. 웹 서버는 클라이언트의 IP 주소 대신 프락시 서버의 IP주소를 본다.
  일부 프락시는 원본 IP를 보존하려고 `Client-ip` 나 `X-Forwarded-For` HTTP 같은 확장 헤더를 추가하여 이를 해결하려 하지만 모든 프락시가 이런식으로 동작하진 않는다.

## 11.4 사용자 로그인

IP 주소로 사용자를 식별하는것 보다, 웹서버는 사용자 이름과 비밀번호를 요구하여 명시적으로 식별 요청을 할 수 있다.

웹 사이트 로그인이 더욱 쉽도록 HTTP는 `WWW-Authenticate`와 `Authorization` 헤더를 사용해 웹사이트에 사용자 이름을 전달하는 자체적인 체계를 갖고있다. 한번 로그인 하면 브라우저는 사이트로 보내는 모든 요청에 이 로그인 정보를 보내므로 웹 서버는 그 로그인 정보를 항상 확인할 수 있다.

서버에서 사이트에 접근 전 로그인을 시키고자 하면 HTTP 401 Login Required 응답 코드를 보낸 후, 다음 요청 부턴 `Authorization` 헤더에 그 정보를 기술하여 보내도록 한다.

브라우저는 요청마다 해당 사용자의 식별 정보 토큰을 `Authorization` 헤더에 담아 서버로 전송하여 한 세션이 진행되는 내 그 사용자에 대한 식별을 유지한다.

## 11.5 뚱뚱한 URL

사용자의 상태 정보를 포함하고 있는 URL을 뚱뚱한 URL이라고 한다. 사용자가 그 사이트를 돌아다니면 웹 서버는 URL에 있는 상태 정보를 유지하는 동적 하이퍼링크를 생성한다.

이는 캐시를 사용할 수 없고, 서버 부하를 가중시키며, URL 이탈, 세션간 지속성의 부재 등의 심각한 문제가 있다.

## 11.6 쿠키

쿠키는 사용자를 식별하고 세션을 유지하는 방식 중에서 가장 널리 사용되는 방식이다. 쿠키는 캐시와 충돌할 수 있어서, 대부분의 캐시나 브라우저는 쿠키에 있는 내용물을 캐싱하지 않는다.

### 11.6.1 쿠키의 타입

- **세션 쿠키(Session Cookie)**
  - 사용자가 사이트를 탐색할 때, 관련된 설정과 선호 사항들을 저장하는 임시 쿠키
  - 브라우저를 닫으면 삭제됨
- **지속 쿠키(Persistent Cookie)**
  - 디스크에 저장되어 브라우저를 닫거나 컴퓨터를 재시작 해도 남아있음.

두 쿠키의 차이점은 파기되는 시점이다. `Discard` 파라미터가 설정 되어있거나, `Max-Age`, `Expires` 파라미터가 없으면 세션 쿠키가된다.

### 11.6.2 쿠키는 어떻게 동작하는가

처음 사용자가 웹사이트에 방문하면 웹 서버는 사용자에대해 아무것도 모른다. 웹서버는 사용자가 다시 돌아왔을때, 해당 사용자를 식별하기 위해 유일한 값을 쿠키에 할당한다. 쿠키는 임의의 이름=값 형태의 리스트를 가지고, 그 리스트는 Set-Cookie 혹은 Set-Cookie2(확장헤더) 같은 HTTP 응답헤더에 기술되어 사용자에게 전달된다.

- 예시 : `Cookie: name=”Brian Totty”; phone=”555-1212”`

### 11.6.3 쿠키 상자: 클라이언트 측 상태

쿠키의 기본적인 발상은 브라우저가 서버 관련 정보를 저장하고, 사용자가 해당 서버에 접근할 때마다 그 정보를 함께 전송하게 하는 것이다. 브라우저는 쿠키 정보를 저장할 책임이 있는데 이 시스템을 ‘클라이언트 측 상태’라고한다. 쿠키 명세서에서 이 공식적인 이름은 ‘HTTP 상태 관리 체계’이다.

### 11.6.4 사이트마다 각기 다른 쿠키들

브라우저는 보통 각 사이트에 두개 혹은 세개의 쿠키만을 보낸다. 또한 쿠키를 생성한 서버에게만 쿠키에 담긴 정보를 전달한다.

- **쿠키를 전부다 보내면 발생되는 문제들**
  - 쿠키를 모두 전달하면 성능 저하 발생
  - 쿠키들은 대부분 서버에 특화된 이름/값 쌍을 포함하고 있기 때문에 대부분의 사이트에서는 인식하지 않는 무의미한 값
  - 타 사이트에 쿠키정보를 전부 전달 할 경우 잠재적인 개인정보 문제 발생 야기
- `Set-cookie: perf=compact; domain=”airtravelbargain.com”; path=/autos/`

**쿠키 Domain 속성**
→ 서버는 쿠키를 생성할 때 Set-Cookie 응답헤더에 Domain속성을 기술해서 어떤 사이트가 그 쿠키를 읽을 수 있는지 제어할 수 있다.

**쿠키 Path 속성**
→ URL 경로의 앞부분만 가리키는 Path 속성을 기술해서 해당 경로에 속하는 페이지만 쿠키를 전달할 수 있다.

### 11.6.5 쿠키 구성 요소

현재 사용되는 쿠키 명세에는 Version 0쿠키(넷스케이프 쿠키)와 Version 1쿠키(RFC 2965)가 있다.

### 11.6.6 Version 0(넷스케이프) 쿠키

최초의 쿠키 명세는 넷스케이프가 명세 했으며, Version0 쿠키는 Set-Cookie 응답헤더와 Cookie 요청 헤더와 쿠키를 조작하는 데 필요한 필드를 정의 하였다.

- Version 0 Set-Cookie 헤더

| Set-Cookie 속성 | 설명                                 |
| --------------- | ------------------------------------ |
| 이름=값         | 필수속성. 아래 속성들은 다 선택 속성 |

`Set-Cookie: custom=Mary` |
| Expires | 쿠키의 생명주기를 가리킴. 일자에 다다르면 쿠키는 삭제됨.
요일, DD-MM-YY HH:MM:SS GMT

`Set-Cookie: custom=Mary expires=Wednesday, 09-Nov-99 23:12:40 GMT` |
| Domain | 이 속성에 기술된 도메인을 사용하는 서버 호스트명으로만 쿠키 전송

`Set-Cookie: custom=Mary domain="joes-hardware.com"` |
| Path | 서버에 있는 특정 문서에만 쿠키 할당.

`Set-Cookie: custom=Mary path=/orders` |
| Secure | HTTP가 SSL 보안 연결을 사용할때만 쿠키 전송

`Set-Cookie: custom=Mary secure` |

요청 속성과 일치하며, 파기되지 않은 쿠키들을 Cookie헤더에 이어서 함께 보냄

### 11.6.7 Version 1(RFC 2965) 쿠키

넷스케이프 표준보다 복잡함. 추가된 변경사항은 아래와 같음.

- 쿠키마다 그 목적을 설명하는 설명문이 있음
- 파기 주기와 상관없이 브라우저가 닫히면 쿠키를 강제로 삭제할 수 있음
- 절대 날자 값 대신에 초 단위의 상대값으로 쿠키의 생명주기를 결정할 수 있음(Max-age)
- 단순히 도메인 경로 뿐 아니라 URL 포트 번호로도 쿠키 제어 가능
- 도메인, 포트, 경로 필터가 있으면 Cookie 헤더에 담아 되돌려 보냄
- 호환되는 버전번호
- 사용자 이름과 추가적인 키워드를 구별하기 위해 Cookie헤더에 $ 접두어가 들어가있음

### 11.6.8 쿠키와 세션 추적

쿠키는 웹 사이트에 수차례 트랜젝션을 만들어내는 사용자를 추적하는 데 사용한다.

### 11.6.9 쿠키와 캐싱

쿠키 트랜젝션과 관련된 문서를 캐싱하는 것은 주의해야한다. 이전 사용자의 쿠키가 다른 사용자에게 할당되어 버리던가, 누군가의 개인정보가 다른이에게 노출되는 상황이 발생될 수 있다.

- **캐시되지 말아야할 문서가 있다면 표시해야함**
  - Set-Cookie 헤더를 제외하고 캐시를 해도 되는 경우라면 `Cache-Control:no-cache=”Set-Cookie”`를 기술하여 표현한다. (캐시를 해도 되는경우는 `Cache-Control:public`)
- **Set-Cookie 헤더를 캐시하는 것을 유의해야함**
  - `Cache-Control: must-revalidate, max-age=0` 모든 요청마다 원서버와 재 검사를 시킨다
- **Cookie 헤더를 가지고 있는 요청을 유의해야함**
  - 캐시 이미지에 파기 시간이 0 인 Cookie 헤더를 설정해서 매번 재검사하도록 강제

### 11.6.10 쿠키, 보안 그리고 개인정보

캐시 정책을 잘 사용하여 개인 정보 정책에만 유의한다면 트랜잭션상의 편리함이 크다.
