# 13. 다이제스트 인증

기본인증은 편하고 유연하지만 절대 안전하지 않다. 기본 보안을 안전하게 이용하는 유일한 방법은 SSL과 결합해서 사용하는 방법이 있다.

다이제스트 인증은 기본 인증과 호환되는 대체재로써 널리 쓰이지는 않지만 개념은 보안 트랜젝션을 구현하고자 하는데 유용하다.

## 13.1 다이제스트 인증의 개선점

안전한 HTTP 트랜잭션을 위한 더 안전한 방법은 TLS와 HTTPS를 사용하는것이다.

- 다이제스트 인증의 특징
  - 비밀번호를 절대로 네트워크를 통해 평문으로 전송하지 않음
  - 인증 체결을 가로채서 재현하려는 악의적인 사람들 차단
  - 구현하기에 따라서 메시지 내용 위조를 막는것도 가능
  - 그외 몇몇 알려진 형태의 공격을 막음

### 13.1.1 비밀번호를 안전하게 지키기 위해 요약 사용하기

다이제스트는 **절대 비밀번호를 네트워크를 통해 보내지 않는다**.

비밀번호를 보내는 대신, 클라이언트는 비가역적으로 섞은 **지문(fingerpring)** 혹은 **요약(digest)**를 보낸다.

서버와 클라이언트는 둘다 비밀번호를 알고 있으므로 서버는 클라이언트가 보낸 정보가 비밀번호에 알맞게 대응하는지 검사할 수 있다.

### 13.1.2 단방향 요약

요약은 `정보 본문의 압축` 이다. 요약은 단방향 함수로 동작하고, 일반적으로 입력 가능한 무한가지의 모든 입력값들을 유한한 범위의 압축으로 변환한다.

인기 있는 요약 함수 중 하나인 MD5는 임의의 바이트 배열을 원래 길이와 상관없이 128비트 요약으로 변환한다.

요약함수는 보통 암호 체크섬(cryptographic checksums)로 불리며, 단방향 해시 함수거나 지문함수(fingerprint function)이다.

### 13.1.3 재전송 방지를 위한 난스(nonce) 사용

비밀번호를 모른다고 해도 요약을 가로채서 서버로 몇번이고 재전송할 수 있기 때문에 요약은 비밀번호와 다름없다.

이런 재전송 공격을 방지하기 위해 서버는 클라이언트에 `난스` 라고 불리는 특별한 증표를 건내준다. 이는 1밀리초마다 또는 인증할때 마다 값이 바뀐다.

난스를 비밀번호에 섞으면 난스가 바뀔때 마다 요약도 바뀌게 만들어준다. 이것은 재전송 공격을 막아준다. 왜냐하면 저장된 비밀번호 요약은 특정 난스 값에 대해서만 유효하고, 비밀번호 없이 공격자가 올바른 요약을 게산하는것은 가능하지 않기 때문이다.

난스는 WWW-Authenticate 인증 요구에 담겨서 서버에서 클라이언트로 넘겨진다.

### 13.1.4 다이제스트 인증 핸드셰이크

HTTP 다이제스트 인증 프로토콜은 기본 인증에서 사용하는것과 비슷한 헤더를 사용하는, 강화된 버전의 인증이다. 기존 헤더에 몇몇 옵션이 추가되었고, 선택적인 헤더인 Authorization-Info가 새로 추가되었다.

- 다이제스트 인증의 세 단계 핸드셰이크 과정
  1. 서버에서 nonce 값 계산
  2. 서버는 난스를 `WWW-Authenticate` 인증요구 메세지에 담아, 서버가 지원하는 알고리즘 목록과 함께 클라이언트에 전송
  3. 클라이언트는 알고리즘을 선택하고 비밀번호와 그 데이터에 대한 요약(digest)를 계산
  4. 클라이언트는 Authorization메세지에 요약을 담아 서버에게 돌려줌. 만약 클라이언트가 서버를 인증하길 원한다면 클라이언트 난스를 보낼 수 있음
  5. 서버는 요약, 선택한 알고리즘, 그 외 보조 데이터들을 받고 클라이언트가 했던 그대로 요약을 계산함.
     그 다음 자신이 계산한 요약과 네트워크로 전송되어 온 요약이 서로 같은지 확인
     만약 클라이언트가 대칭적으로 서버에게 클라이언트 난스를 갖고 인증을 요구했다면 클라이언트 요약이 만들어짐. 또한 서버는 클라이언트가 미리 다음번 요약을 올바르게 생성할 수 있도록 다음번 난스를 미리 계산해서 클라이언트에 넘겨줄 수 있음

## 13.2 요약 계산

다이제스트 인증으 ㅣ핵심은 공개된 정보, 비밀정보, 시한부 난스 값을 조합한 단방향 요약이다.

### 13.2.1 요약 알고리즘 입력 데이터

- 단방향 해시함수 H(d) 와 요약함수 KD(s,d). 여기서 s는 비밀(secreat), d는 데이터를 의미한다
- 비밀번호 등 보안 정보를 담고 있는 데이터 덩어리. A1이라 칭함
- 욫어 메세지의 비밀이 아닌 속성을 담고있는 데이터 덩어리. A2라 칭함

A1, A2 두 조각의 데이터는 요약을 생성하기 위해 H와 KD에 의해 처리된다.

### 13.2.2 H(d)와 K(s,d) 알고리즘

다이제스트 인증은 여러 요약 알고리즘을 선택할 수 있도록 지원하며 알고리즘이 정해지지 않았다면 MD5가 기본값이다. (RFC-2517에서 제안된 두 알고리즘은 MD5와 MD5-sess이다 - sess는 세션을 뜻함.)

### 13.2.3 보안 관련 데이터(A1)

A1은 사용자 이름, 비밀번호, 보호 영역, 난스와 같은 비밀 보호 정보로 이루어져 있다.

A1은 메시지 자체가 아닌 비밀 정보와만 관련이 되어 있다. A1은 H, KD, A2와 마찬가지로 요약을 계산하기 위해 사용된다.

| 알고리즘                                                                                    | A1                                                | 설명                                                                                                                 |
| ------------------------------------------------------------------------------------------- | ------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------- |
| MD5                                                                                         | A1=<사용자>:<영역>:<비밀번호>                     | 모든 요청마다 단방향 해시를 실행한다. A1은 사용자이름, 영역, 비밀번호를 콜론으로 연결한것이다.                       |
| MD5-sess                                                                                    | A1=MD5(<사용자>:<영역>:<비밀번호>):<난스>:<c난스> | 사용자 이름, 영역, 비밀번호에 대한 해시를 계산한 결과 뒤에 현재 난스와 클라이언트 난스(c난스)를 붙인 것이 A1이 된다. |
| CPU를 많이 사용하는 해시계산은 처음 WWW-Authenticate 핸드셰이크를 할 때 단 한번만 수행한다. |

### 13.2.4 메세지 관련 데이터(A2)

A2는 URL, 요청 메서드, 메시지 엔터티 본문과 같은 메세지 자체의 정보를 나타낸다. 메서드, 리소스, 메세지의 위조를 방지하기 위해 사용되며 H, KD, A1과 마찬가지로 요약을 계산하기 위해 사용된다.

| qop           | A2                                                |
| ------------- | ------------------------------------------------- |
| 정의되지 않음 | <요청 메서드>:<uri지시자값>                       |
| auth          | <요청 메서드>:<uri지시자값>                       |
| auth-int      | <요청 메서드>:<uri지시자값>:H(<요청 엔터티 본문>) |

uri지시자값은 요청줄에서 가져온 요청 URI이다.

이것은 ‘\*’, ‘absoluteURL’, ‘abs_path’중 아무거나 될 수 있지만 반드시 요청 URI와 일치해야 한다. 요청 URI가 absoluteURL이면 uri지시자 값도 반드시 absoluteURL이어야한다.

### 13.2.5 요약 알고리즘 전반

RFC2517은 주어진 H,KD,A1,A2로 요약을 계산하는 두 가지 방법을 정의한다.

| qop           | 알고리즘                     | 펼쳐진 알고리즘                                                  |
| ------------- | ---------------------------- | ---------------------------------------------------------------- |
| 정의되지 않음 | <정의되지 않음> MD5 MD5-sess | `MD5`(`MD5`(`A1`):<`난스`>:`MD5`(`A2`))                          |
| auth          | <정의되지 않음> MD5 MD5-sess | `MD5`(`MD5`(`A1`):<`난스`>:<`nc`>:<`c난스`>:<`qop`>:`MD5`(`A2`)) |
| auth-int      | <정의되지 않음> MD5 MD5-sess | `MD5`(`MD5`(`A1`):<`난스`>:<`nc`>:<`c난스`>:<`qop`>:`MD5`(`A2`)) |

### 13.2.6 다이제스트 인증 세션

어떤 보호공간을 위한 WWW-Authenticate 인증 요구에 대한 클라이언트 응답은 그 보호공간에 대한 인증 세션을 시작하게 한다. 인증 세션은 클라이언트가 보호공간의 또 다른 서버로부터 다른 WWW-Authenticate 인증 요구를 받을때까지 지속된다.

### 13.2.7 사전(preemptive) 인가

사전인가는 요청/인증요구 단계를 거치지 않고 미리 Authorization 헤더를 서버에 제공한다. 이로인해 성능 개선이 될 수 있다.

- 사전 인가를 위해 클라이언트가 새 WWW-Authenticate 인증요구를 기다리지 않고 올바른 난스를 취할 수 있는 방법
  - 서버가 다음 난스를 Authentication-Info 성공 헤더에 미리 담아 보낸다
  - 서버가 짧은 시간동안 난스를 재사용하는것을 허용한다
  - 클라이언트와 서버가 동기화되어이쏙 예측 가능한 난스 생성알고리즘을 사용한다.

### 13.2.8 난스 선택

난스의 내용은 불투명하고 구현 의존적이다.

- RFC2517의 가상 난스 공식 제안
  - `BASE64(타임스탬프H: 타임스탬프”:” ETag”:” 개인키))`
    → 타임스탬프: 서버에서 생성된 시간 혹은 아무것이나 반복 불가능한 값,
    → ETag: 요청된 엔티티에 대한 ETag 헤더값
    → 개인키: 서버만이 알고있는 값

### 13.2.9 상호 인증

상호인증은 RFC2617로 표준화 되었으며 qop지시자가 존재할 때는 항상 수행하고, 없다면 수행하지 말아야한다.

## 13.3 보호 수준(Quality of Protection) 향상

qop 필드는 요약 헤더의 세가지 헤더 `WWW-Authenticate`, `Authorization`, `Authentication-Info` 에 모두 존재할 수 있다.

qop필드는 클라이언트와 서버가 어떤 보호기법을 어느 정도 수준으로 사용할 것인지 협상할 수 있게 해준다.

서버는 우선 `WWW-Authenticate` 헤더에 qop옵션을 쉼표로 구분된 목록 형태로 내보낸다. 그 후 클라이언트는 그 옵션들 중 지원할 수 있으면서 동시에 자신의 요구에도 맞는 것을 선택하고, 그것을 `Authorization` 헤더의 qop필드에 담아 돌려준다.

- qop=”auth” : 인증
- qop=”auth-int” : 인증 및 메세지 무결성 보호

### 13.3.1 메세지 무결성 호보

`auth-int` 일 경우 계산되는 H(엔터티 본문)은 메세지 본문의 해시가 아닌 엔터티 본문의 해시이다.

이것은 송신자에 의해 어떠한 전송인코딩이 적용되기도 전에 먼저 계산되고 그 후 수신자에 의해 제거된다. 이것이 멀티파트 경계와 가 ㄱ파트의 임베딩된 헤더를 포함한다는것에 주의해아한다.

### 13.3.2 다이제스트 인증 헤더

기본, 다이제스트 인증 프로토콜 양 쪽 모두 `WWW-Authenticate` 헤더에 담겨 전달되는 인증요구와, `Authorization` 헤더에 담겨 전달되는 인가 응답을 포함한다. 다이제스트 인증은 여기에 선택적인 `Authentication-Info` 헤더를 추가했다.

## 13.4 실제 상황에 대한 고려

### 13.4.1 다중 인증 요구

서버는 한 리소스에 대해 여러 인증을 요구할 수 있다. 다중 인증 요구에 직면했을 때, 클라이언트는 반드시 자신이 지원할 수 있는 가장 강력한 인증 매커니즘을 선택해야한다.

다양한 인증 옵션을 제공하는 경우 ‘가장 허약한 연결 부분’에 대한 보안 우려가 있다는것은 명확하기 때문에 서버는 기본인증을 제한적으로만 사용해야 할것이며, 관리자는 사용자에게 보안수준이 다른 여러 시스템에서 같은 비밀번호를 사용하는 것의 위험성에 대해 경고해야 한다.

### 13.4.2 오류 처리

다이제스트 인증에서, 지시자나 그 값이 적절하지 않거나 요구된 지시자가 빠져있는 경우 알맞은 응답은 400 Bad Request이다.

요청의 요약이 맞지 않으면 로그인이 실패했음을 기록해두는게 좋다. 반복되는 실패는 공격자가 비밀번호를 추측 시도하고있음을 의미한다.

### 13.4.3 보호 공간(Protection Space)

영역 값은, 접근한 서버의 루트 URL과 결합되어 보호공간을 정의한다.

### 13.4.4 URI 다시쓰기

프락시는 가리키는 리소스의 변형 없이 구문만 고쳐서 URI를 다시 쓰기도 한다

- 호스트 명은 정규화 된거나 IP주소로 대체될 수 있다
- 문자들은 ’%’ escape 형식으로 대체될 수 있다.
- 특정 원 서버로부터 가져오는 리소스에 영향을 주지 않는, 타입에 대한 추가 속성이 URI 끝에 붙거나 중간에 삽입될 수 있다.

### 13.4.5 캐시

어떤 공유 캐시가 `Authorization` 헤더를 포함한 요청과 그에 대한 응답을 받은 경우, 다음의 두 Cache-Control 지시자 중 하나가 응답에 존재하지 않는 한 다른 요청에 대해 그 응답을 반환해선 안된다.

## 13.5 보안에 대한 고려사항

### 13.5.1 헤더 부당 변경

헤더 부당 변경에 대해 항상 안전한 시스템을 제공하기 위해 양 종단 암호화 헤더에 대한 디지털 서명이 필요하다.

### 13.5.2 재전송 공격

누군가 어떤 트랜잭션에서 엿들은 인증 자격을 달느 트랜잭션을 위해 사용하는 것을 말한다. (GET 요청에 대한 이슈이긴 하다)

재전송 공격을 완전히 피할 수 있는 방법은 매 트랜잭션마다 유일한 난스값을 사용하는 것이다.

### 13.5.3 다중 인증 매커니즘

클라이언트가 언제나 가능한 가장 강력한 인증제도를 선택하여 다중인증 메커니즘에 대한 문제를 해결해야한다.

다른 선택지는 가장 강력한 인증 제도만 유지하는 프락시 서버를 사용하는 것이다. (이는 사내 네트워크와 같은 경우에만 실현 가능하다.)

### 13.5.4 사전(dictionary) 공격

사전공격은 전형적인 비밀번호 추측 공격이다.

이 문제를 해결할 방법은 크래킹 하기 어렵도록 상대적으로 복잡한 비밀번호를 사용하는것과 비밀번호 만료 정책을 정하는 것이다.

### 13.5.5 악의적인 프락시와 중간자 공격(Main-in-the-Middle Attack)

많은 인터넷 트래픽이 한 프락시에서 다른 프락시로 이동한다. 이들 중 어떤 요청이 프락시를 통과하는줄도 모르기 때문에 보안이 허술하게 된다면 중간자 공격에 취약하게 될 수 도 있다.

가능한 해결책은 클라이언트가 사용자에게 인증의 강도를 시각적으로 보여주는것, 클라이언트가 언제나 가능한 한 가장 강력한 인증을 선택하도록 설정하는것이 있다.

### 13.5.6 선택 평문 공격

다이제스트 인증을 사용하는 클라이언트는 응답을 생성하기 위해 서버가 제공한 난스를 사용하는데, 보안이 허술하거나 악의적인 프락시가 트래픽 중간에 기어든다면 어렵지 않게 클라이언트가 응답을 계산하기 위한 난스를 제공할 수 있다. 응답을 계산하기 위해 알려진 키를 사용하는 것은 응답의 암호 해독을 쉽게 한다. 이를 선택 평문 공격이라 한다.

- 미리 계산된 사전 공격
  - 사전공격과 선택 평문 공격의 조합
- 자동화된 무차별 대입 공격
  - 주어진 범위 내에서 가능한 모든 비밀번호를 열거한다

해결책으로는 클라이언트가 서버에서 제공된 난스 대신 선택적인 c난스 지시자를 사용하여 응답을 생성할수 있도록 설정하는 것이다. 여기에 강력한비밀번호를 강제하는 정책과 비밀번호 만료 매커니즘을 사용하는것도 좋은 방법이다.

### 13.5.7 비밀번호 저장

다이제스트 인증 매커니즘은 사용자 응답을 서버 내부에 저장된것과 비교한다. 유닉스 장치의 전통적인 비밀번호 파일과 달리 다이제스트 인증 비밀번호 파일이 유출되면 영역의 모든 문서는 즉각 공격자에게 노출된다.암호 해독과정은 필요없다.

해결책

- 비밀번호 파일이 평문으로 된 비밀번호를 포함하고 있다고 생각하고 안전하게 보호한다.
- 영역 이름이 유일함을 보장하며, 비밀번호 파일이 유출되더라도 피해를 특정 영역으로 국소화한다. 호스트와 도메인을 포함한 완전한 영역 이름은 이 요구를 만족한다.
